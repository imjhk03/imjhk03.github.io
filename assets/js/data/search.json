[ { "title": "Multiple Pages Xcode Playground", "url": "/posts/multiple-pages-xcode-playground/", "categories": "", "tags": "swift playground", "date": "2023-01-09 00:00:00 +0000", "snippet": "간단한 스위프트 코드를 작성할 때 Xcode Playground를 사용한다. Xcode Playground 파일을 생성하면 하나의 플레이그라운드에서 코드를 작성하게 되는데, 여러 플레이그라운드 파일들을 묶고 싶은 경우가 있다. 예를 들어, 하나의 주제를 가지고 다양한 코드 방법을 파일별로 정리하거나 문법 공부할 때 문법별로 정리하는 경우가 있다. 이럴...", "content": "간단한 스위프트 코드를 작성할 때 Xcode Playground를 사용한다. Xcode Playground 파일을 생성하면 하나의 플레이그라운드에서 코드를 작성하게 되는데, 여러 플레이그라운드 파일들을 묶고 싶은 경우가 있다. 예를 들어, 하나의 주제를 가지고 다양한 코드 방법을 파일별로 정리하거나 문법 공부할 때 문법별로 정리하는 경우가 있다. 이럴 때 멀티 페이지를 만드는 방법을 소개하겠다.Playground Page 생성하기Xcode에서 플레이그라운드를 만들고 나서 File &gt; New &gt; Playground Page를 선택하면 하나의 플레이그라운드 프로젝트 안에 ‘Untitled Page’ 와 ‘Untitled Page 2’가 생기는 것을 확인할 수 있다.이런 식으로 하나의 플레이그라운드 안에서 여러 플레이그라운드 페이지를 만들 수 있다.여기서 조금 더 문서처럼 사용할 수 있게 마크업 문법을 활용해서 플레이그라운드 페이지를 정리하는 방법을 소개하겠다.플레이그라운드에서 마크업 사용하기목차 만들기여러 플레이그라운드 페이지를 만들면 목차 역할을 하는 플레이그라운드 페이지를 만들면 편하다. 아래와 같이 Introduction 플레이그라운드 페이지를 만들고 마크업을 사용해서 텍스트 크기를 제일 크게 적용하도록 ‘#’ 하나를 추가했다. 아직까지는 크게 변한 게 없다.여기서 Editor &gt; Show Rendered Markup을 선택하면 아래와 같이 큰 타이틀이 가진 마크업이 나타난 것을 확인할 수 있다.자주 사용할 수 있기 때문에 Xcode Key Binding을 이용해서 빠르게 마크업 랜더링 하는 것을 확인해 볼 수 있다. 아래와 같이 Xcode Settings &gt; Key Binding에서 markup 검색해서 설정하면 된다.목차를 순서가 있는 목록이나 순서가 없는 목록으로 만들어서 사용할 수 있다. 아래와 같이 숫자를 붙이거나 ‘*’ 혹은 ‘-‘를 사용하면 된다.플레이그라운드 네비게이션 연결하기마크업은 링크를 지원하기 때문에 웹사이트랑 이메일 링크를 추가해서 연결할 수 있다. 이런 링크를 이용해서 목차에 링크를 추가해서 플레이그라운드 페이지로 이동할 수 있게 가능해진다. 아래처럼 대괄호([ ])랑 소괄호(( ))를 이용해서 소괄호 안에 링크를 추가하면 된다. 링크는 띄어쓰기를 지원하지 않기 때문에 띄어쓰기가 플레이그라운드 제목에 있을 경우, ‘%20‘으로 사용해야 한다.새로 생긴 플레이그라운드 페이지를 보면 위에는 Previous랑 아래에는 Next가 있는 것을 볼 수 있다. 마크업 랜더링한 상태에서 누르면 페이지 이동이 되는 것을 확인할 수 있다.더 많은 마크업 문법은 코드로 간단하게 정리를 했고 더 깊이 있는 것은 애플 문서나 검색해 보면 더 확인할 수 있다.참고Multi Page Xcode PlaygroundMarkup Formatting Reference: Markup OverviewSwift Playground Markup Formatting Reference" }, { "title": "2022 하반기 회고", "url": "/posts/2022-the-second-half-retrospect/", "categories": "", "tags": "restrospect", "date": "2022-12-31 00:00:00 +0000", "snippet": "2022 상반기 회고벌써 2023년이 코앞이다. 하반기는 상반기에 비해서 시간이 빨리 지나간 것 같다. 상반기에는 일 위주로 작성했다면 이번 하반기에는 개인적인 일과 함께 회고를 작성했다.운동과 여행올해 2월부터 클라이밍 운동을 시작했는데 처음에는 많이 힘들었지만 재밌어서 꾸준히 하고 있다. 결국에는 클라이밍화랑 운동복을 따로 사서 운동하러 갈 때마다...", "content": "2022 상반기 회고벌써 2023년이 코앞이다. 하반기는 상반기에 비해서 시간이 빨리 지나간 것 같다. 상반기에는 일 위주로 작성했다면 이번 하반기에는 개인적인 일과 함께 회고를 작성했다.운동과 여행올해 2월부터 클라이밍 운동을 시작했는데 처음에는 많이 힘들었지만 재밌어서 꾸준히 하고 있다. 결국에는 클라이밍화랑 운동복을 따로 사서 운동하러 갈 때마다 챙기고 있다. 요즘은 바빠서 많이 못 가고 있지만, 틈날 때 가려고 노력하고 있다. 올해 내가 했던 일들 중에 클라이밍 운동을 시작한 게 제일 잘한 것 같다. 건강을 생각해서 앞으로도 쭉 할 계획이다.지난 상반기 회고에도 작성했지만 힘들고 지치니깐 쉬고 싶은 마음이 항상 들었다. 그래서 제주도 여행 가서 호화롭게 휴식을 즐겼다. 제주도는 거의 매년 가는 것 같은데, 관광이 아닌 자연을 즐기러 간 거여서 너무 좋았다. 어디를 보러 가거나 뭐를 먹으러 가기에 바쁜 일정 없이 자연이랑 어울린 호텔에서 푹 쉬었다. 제주도 여행뿐만 아니라 부산도 즉흥적으로 가서 바다를 즐기고, 친구들이랑 정선 가서 겨울 산들을 구경했다. 잠깐 일상을 벗어나기 위해서는 여행만 한게 없는 것 같다. 내년에는 가족 여행 크게 계획하고 있어서 지출을 줄이고 여행도 줄일 계획이다. 얼른 내년 가족 여행을 가고 싶다.관리자/매니저로서 일아주 조금씩 관리자/매니저로서의 일을 하기 시작했다. 상반기에는 스쿼드 iOS 개발 파트를 리드했고, 하반기에는 정규 차수 관련해서 일정 같은 것을 체크하기 시작했다. 상반기에는 스쿼드 개발자가 많지 않아서 코드 작성하면서 커뮤니케이션 업무를 했는데, 하반기에는 차수 작업 개발자가 많아지면서 개발 업무를 줄이고 일정 체크하는 일 위주로 많이 했다.여전히 어려운 것 같다. 일정을 잘 못 지키는 개발자들도 있었고 QA 기간에 이슈 티켓이 많이 생기고 있다. 개발자로 생각 안 하고 관리자/매니저 위치로 생각하니깐 개인이 아닌 팀 협업 위주로 생각하게 된다. 업무를 어떻게 더 효율적으로 할지, 일정을 어떻게 관리할지, 팀 생산성을 떨어트리는 일이 어떤 것들이 있는지 고민을 많이 하게 되었다.그러다 보니깐 코드를 작성하는 일이 줄어드는 것 같다. 코드 리뷰는 기본적으로 하는데 되도록이면 모든 PR를 확인하고 일정 체크나 문제가 되는 일이 생기면 팀장님이랑 커뮤니케이션하고, 퇴근 시간이 되면 하루가 순식간으로 지나갔다. 밸런스 유지하는 게 제일 어려운 것 같은데, 내년에는 더 나은 상황이 되길 노력해야겠다.회고의 중요성사내 주간 뉴스레터를 상반기부터 진행했는데, 매주 일요일마다 그 주에 올라온 iOS 프로그래밍 글이나 개발자 관련 이야기들을 훑어보고 뉴스레터에 작성해서 발행했다. 그러다 보니 일요일마다 그 주에 어떤 일들이 있었는지 자연스럽게 회고를 하게 되었다. 기억을 다시 상기시켜서 좋았고, 매번 까먹게 되는 것을 다시 기록으로 남길 수 있어서 나중에 찾기 편해졌다.하반기에는 개발 업무 일지를 작성하기 시작했다. 매일은 못 하더라도 생각날 때마다 작성하려고 노력했는데, 그날 어떤 업무를 했는지 기록할 수 있어서 좋았다. 매년 새로운 일을 하지 않고 반복적인 업무를 하다 보니 작성해야 하는 느낌이 들지 않았는데, 이번에는 일정 관리 일까지 하다 보니 개발 일지 쓰는 게 도움이 되었다. 매일 이렇게 작성하다 보면 나중에 1년을 되돌아보면서 어떤 업무를 주요했는지 볼 수 있을 것 같아서 도움이 될 것 같다. 물론 작성하지 못한 날들이 많았지만, 되도록이면 업무 관한 것도 작성하고 개인적인 느낌이나 일화들도 따로 작성하려고 노력하고 있다.회고도 나중에는 블로그 글감으로도 도움이 될 것 같다. 그날 업무를 하다가 새로운 거 알게 되면 사파리 읽기 목록에 저장하고 나중에 보는 식으로 했다. 그런데 개발 업무 일지에 작성하면 나중에 정리하는 시간을 따로 가지면서 조금 더 깊게 자료를 더 찾거나 공부하게 되는 계기가 될 것 같다.정착해 가는 과정올해는 야근도 많이 하고 새로운 일을 하는 등 어려움과 힘듦이 있었지만, 새로운 것도 도전해 보았던 해였다. 클라이밍 운동을 시작으로 꾸준히 내가 좋아하는 운동을 찾게 되었고, 집 근처 오마카세도 처음 가봤는데 너무 좋아서 자주 가고, 식당을 옮겼는데도 가고 있다. SNS 통해서 접한 여러 다양한 의견들을 보면서 내 가치관이 점점 명확해지고 있다. 회사 일도 큰 변화는 없지만 새로운 일을 맡게 되면서 점점 내가 갖춰야 하는 자세나 능력이 무엇이어야 하는지 맞춰가고 있다. 같이 일하고 있는 사람들 덕분에 회사도 편하게 일을 하고 있는 것 같다.매일은 아니더라도 매주 회고를 하면서 조금씩 정착해 가는 것 같은 느낌이 들었다. 뭔가 안정감을 느끼기 시작하는 것 같다. 이 안정감을 유지하면서도 너무 편안함을 느끼거나 성장/발전이 없는 삶을 살지 않도록 주의해야 하지만, 내가 어떤 것을 좋아하고 어떤 것을 가치관으로 두는지 명확해져 가는 이 시기를 즐기고 있다. 그래서 앞으로가 더 기대가 된다.새로운 챕터로 가는 여정상반기에 계획했던 일들은 하반기에는 많이 못 해서 아쉬웠다. 일적으로는 밸런스를 찾아가는 과정 때문에 힘들었고 개인적으로는 휴식을 더 취하려고 그래서 못 이룬 게 많았던 것 같다. 그래도 소소한 행복들을 느낄 수 있는 순간들이 많아서 좋았다.작년에는 매일 1% 성장하는 개발자가 되고 싶다고 작성했는데, 올해는 잘 한 것 같다. 매주 회고를 하거나 매일 회고하려고 하는 습관 때문에 어제보다 나은 사람으로 노력한 것 같다. 내년에는 회고를 더 꾸준히 작성해서 내가 못 하거나 알지 못하는 내용들을 보완하는 시간을 더 가지도록 노력해야겠다.연차가 쌓이면 쌓일수록 불안감이나 두려움은 늘 더 생기는 것 같다. 특히나 올해부터는 새로운 챕터로 가고 있어서 기대감도 있지만 압박감이나 부담감이 생기고 있다. 올해 있었던 일들을 바탕으로 내년에는 조금 더 이런 불안감이 덜어낼 수 있는 해가 되었으면 좋겠다. 더 많은 것을 알고 더 많은 것을 결정할 수 있는, 그만큼 성장한 새로운 챕터로 가는 나를 기대해 본다." }, { "title": "레츠스위프트 2022 참석 후기", "url": "/posts/lets-swift-2022/", "categories": "", "tags": "restrospect", "date": "2022-12-06 00:00:00 +0000", "snippet": "2019년 이후로 대면 컨퍼런스 참여하는 것은 이번 Let’s Swift 행사가 처음이었다. 코로나로 인해 대면으로 컨퍼런스 참여하는 게 힘들었는데, 올해부터는 조금씩 소수 인원들만 초대해서 오프라인 컨퍼런스들이 조금씩 생기기 시작했다. 다행히 티켓팅 성공해서 이번 레츠스위프트 행사에 참여할 수 있었다. 그전에 다녔었던 오프라인 컨퍼런스는 나 혼자 다...", "content": "2019년 이후로 대면 컨퍼런스 참여하는 것은 이번 Let’s Swift 행사가 처음이었다. 코로나로 인해 대면으로 컨퍼런스 참여하는 게 힘들었는데, 올해부터는 조금씩 소수 인원들만 초대해서 오프라인 컨퍼런스들이 조금씩 생기기 시작했다. 다행히 티켓팅 성공해서 이번 레츠스위프트 행사에 참여할 수 있었다. 그전에 다녔었던 오프라인 컨퍼런스는 나 혼자 다녔었는데, 이번에는 회사 iOS 팀원들 몇 명이랑 같이 가서 새로웠다. 그래서 행사 때 진행한 세션에 대한 정리보다는 행사 참여하면서 느낀 개인적인 생각을 담겨 후기를 작성했다.스피커와 서포터그동안 iOS 자료들을 검색해 보면 레츠스위프트 때 발표했던 멋진 내용들이 많았는데, 그 세션들을 올해는 실제로 보고 들을 수 있게 되어서 설레었다. 타임 테이블 보면서 어떤 내용들을 봐야 할지 찜했었는데, 어떤 세션들은 스피커와 서포터로 구성된 세션들이 있었다. 처음에는 어떻게 진행되는 건지 궁금했는데, 당일 키노트 내용 들으면서 이해가 되었다.발표 경험이 많지 않는 주니어와 경험이 많은 시니어가 같이 준비하는 세션들이 있었는데, 스피커와 서포터로 연결하면서 주니어에게 발표 경험을 쌓을 수 있게 하는 것들이 매우 인상 깊었다. 개인적으로 멋진 개발자들 중에는 스피커로서 참여하는 개발자들을 많이 봤었는데, 거의 이름이 많이 익숙한 개발자들이 많았다. 그러다 보니 알게 모르게 이런 컨퍼런스의 스피커들은 연차가 많은 개발자들이 주로 스피커로 나와야 하는 게 아닌가 생각이 있었는데, 올해 레츠스위프트는 그런 생각을 다시 생각하게 만들었다.그래서인지 개발 인증서, 비전공 대졸 주니어 개발자의 경험기, PencilKit과 Safari Extension 등 다양한 주제를 다룬 세션들이 많았고, 스피커의 긴장하면서 발표하는 모습을 보면서 새로운 느낌을 받았다. 개인적으로 발표를 하면 긴장을 많이 하고 시선이 집중되는 것을 매우 어려워하는데, 그런 어려움을 극복하고 세션을 준비했을 스피커와 그런 스피커를 옆에서 많이 도움을 주었을 서포터분들이 매우 대단하다고 느꼈다. 스피커로 활동하고 싶은 주니어들과 스피커 활동 노하우를 공유할 수 있는 시니어들이 앞으로 더 많아지면 더 다양한 스피커들이 나오지 않을까 기대하게 된다.세션자리가 부족해서 못 들었던 세션들이 있었지만 그중에 기억이 남는 세션들이 있었다. 요즘 회사에서 고민 중인 아키텍처와 개발 문화와 연관되어 있는 Modular Architecture w/ Tuist와 테크스펙으로 모두가 함께 성장하기 세션들이었다. 확실히 요즘 고민 중인 문제와 비슷한 주제의 세션들에 더 관심이 가게 되었고, 들었던 내용 중에 조금이나마 고민들을 해결할 수 있을 것 같았다. 내용을 조금 더 다듬고 정리해서 팀에 공유를 하고 같이 이야기하는 시간을 가져야겠다고 생각했다. 언젠가 될지는 모르겠지만 나중에 정리해서 글을 남겨야겠다고 생각했다.테크토크 시간에는 많은 개발자들의 고민을 들을 수 있었고 그 고민들에 대한 시니어 개발자들의 이야기를 들을 수 있었다. 좋은 방향들을 제시했고 개인적으로 시니어 개발자들이 생각하는 시니어 개발자의 자세와 역량에 대해서 많이 알 수 있었다. 연차가 쌓이면서 개인적으로 아직 부족하다고 느끼지만, 시니어 개발자로서 커리어가 계속 가고 있는 것을 느끼고 있었는데, 참고하면서 그나마 좋은 시니어 개발자로서 가야겠다고 생각했다.네트워킹역시나 네트워킹 시간은 나에게 어려운 시간인 것 같다. 내향적인 성격을 가져서 먼저 말을 걸고 다가가는 게 어려웠다. S, W, I, F, T 스티커를 모아서 경품 추천할 수 있는 시간에는 우연찮게 5명이 모여서 갔는데, 이때 슬쩍 명함 건네주면서 살짝 스몰톡한게 다였다. 그래도 짧게 이전에 인연이 있었던 이야기들이 나왔고, 내 블로그 글을 봤었던 분도 만났었다. 그리고 트위터를 통해 알게 된 분들과 인사를 나누고 스몰톡도 했고, 세션 끝나고 발표자한테 따로 가서 세션 잘 들었다고 인사도 따로 했었다. 길게는 이야기하지 못했지만, 다음에는 조금 더 자신감 있게 해야겠다고 생각했다.마치며2019년 이후로 처음 대면으로 컨퍼런스 참여했는데, 아쉬운 점들도 있었지만 멋진 컨퍼런스에 참석할 수 있어서 좋았다. iOS 커뮤니티가 점점 더 커지는 것을 느꼈고, 내년에도 참석하고 싶다." }, { "title": "듀얼 모니터 보다 싱글 모니터", "url": "/posts/not-using-multiple-monitors/", "categories": "", "tags": "workflow", "date": "2022-10-24 00:00:00 +0000", "snippet": "아마도 많은 개발자들은 듀얼 모니터를 사용할 것이다. 하나의 모니터에서는 메신저나 개발에 필요한 화면을 띄우고, 다른 모니터로는 개발 프로그램을 열어서 사용하는 게 대부분일 것으로 보인다. 나도 예전에는 맥북프로 화면으로 메신저를 키고 연결된 모니터로 개발 프로그램을 키고 업무를 보았다. 아니면 와이드 모니터를 사서 하나의 모니터에 반을 나눠서 프로그...", "content": "아마도 많은 개발자들은 듀얼 모니터를 사용할 것이다. 하나의 모니터에서는 메신저나 개발에 필요한 화면을 띄우고, 다른 모니터로는 개발 프로그램을 열어서 사용하는 게 대부분일 것으로 보인다. 나도 예전에는 맥북프로 화면으로 메신저를 키고 연결된 모니터로 개발 프로그램을 키고 업무를 보았다. 아니면 와이드 모니터를 사서 하나의 모니터에 반을 나눠서 프로그램을 띄워서 사용했었다.나는 우연히 트위터에서 트윗이랑 글을 읽고 나서, 듀얼 모니터 혹은 와이드 모니터를 사용하지 않고 하나의 모니터로 업무를 보게 되었다. 사용하고 있는 개발 노트북은 맥북프로인데, 클램쉘 모드(clamshell mode)로 해서 하나의 모니터로 업무를 보는데, 생각보다 불편한 점이 없었다.하나의 업무에만 집중하기하나의 모니터에서 하나의 프로그램을 꽉 채워서 보게 되니깐 더 집중을 할 수 있게 되었다. 다른 모니터에서 메신저 알림을 받거나 Spotify 같은 음악 프로그램에서 다음 음악으로 재생하는 등의 동작을 동시에 볼 필요가 없다. 물론 켜놓고 나중에 메신저 알림을 확인하면 되지만, 그 일도 하나의 모니터에서 가능하다. MacOS에서 여러 데스크탑 화면을 만들어 사용할 수 있어, 각 데스크탑 화면에 필요한 프로그램을 넣고 보면 된다. 각 데스크탑에는 어떤 프로그램을 둘지 규칙을 정해서 사용하고 있다. 그리고 필요할 때마다 3 손가락으로 스와이프 해서 데스크탑 이동한다.개발을 하다 보면 메신저를 확인하거나 개발 문서를 같이 보면서 업무를 하게 되는데, 각 화면을 반으로 분리해서 작업을 하면 문제가 없다. 개발 문서나 메신저 알림을 한 화면 크게 볼 필요가 없다. 작게 내가 필요한 만큼 줄이고, 보면서 필요한 부분을 작업하고 다시 각 데스크탑으로 옮기면 된다. 양쪽을 항상 두면서 개발하는 경우가 하루 종일 있지 않는다.물론 업무 특성상 양쪽을 보면서 업무를 봐야 할 수도 있다. 하지만 지금의 내 작업 환경을 생각한다면, 개발 프로그램을 하나의 화면에 집중하면서 개발하는 게 나한테 맞다. 필요할 때 메신저를 확인하거나 개발 문서를 확인하고, 다시 개발 프로그램 화면으로 전환해서 개발한다.사용하는 모니터32인치는 너무 부담이 될 것 같아 27인치 4K 모니터를 구입해서 사용하고 있다. 집이랑 회사랑 동일한 모니터를 사용하고 있어서 어색함이 느껴지지 않는다. 큰 모니터를 쓰면 더 넓게 크게 볼 수 있지만, 오히려 글씨를 키우거나 화면을 확대해서 보는 경우가 많아, 나한테는 27인치 4K가 적당하다.4K를 사용하지만 실제로는 scale 해서 화면을 보고 있다. 주로 텍스트를 많이 보기 때문에 텍스트가 선명하게 잘 보이고 적당한 크기로 봐야 한다. 가끔 영화 같은 긴 영상을 볼 때는 4K로 설정해서 보지만, 보통은 3008x1692 scale로 맞춘다. 퍼포먼스 헤친다는 내용이 설정에 나타나지만, 아직까지는 퍼포먼스 떨어지는 경험을 느껴보지 않아서 괜찮다. 아래는 4K로 설정했을 때와 1692 scale 했을 때의 화면이다.4k3008x1692 scale물론 개인에 따라서 하나의 모니터가 효율적일 수 있고 듀얼 모니터 혹은 그 이상의 모니터를 둬서 업무하는 게 맞을 수 있다. 나는 개인적으로 멀티태스킹이 잘 안되고, 하나의 업무를 볼 때 집중해서 보는 편이기 때문에 하나의 모니터를 사용하고 있다. 그전에는 당연히 듀얼 모니터를 사용하고 와이드 모니터를 사용해서 공간 활용을 적절하게 사용했지만, 몇 개의 글들을 통해서 생각을 바꿨다. 나의 업무 환경 혹은 컴퓨터 사용하는 환경이 바뀌었기 때문에, 기록을 남기고자 글을 작성했다.지금 모니터도 만족하지만 언젠가는 애플에서 만든 모니터를 구매해서 써보고 싶은 의향이 있다. 물론 이때도 지금 쓰고 있는 모니터를 처분하고 하나의 모니터만으로 활용할 생각이다.참고Why I Stopped Using Multiple MonitorsTime to upgrade your monitor" }, { "title": "코드 리뷰를 개선할 수 있는 Danger + SwiftLint Plugin", "url": "/posts/improve-code-review-with-danger/", "categories": "", "tags": "optimization", "date": "2022-08-30 00:00:00 +0000", "snippet": "깃허브에서 PR을 올려서 코드 리뷰를 받고 있는데, 코드 리뷰를 하다 보면 코드 스타일 등에 대해서 놓친 경우가 있어서 코멘트를 다는 경우가 있다. 예를 들면 네이밍 컨벤션이 잘 지켜지지 않거나 자주 놓치는 접근 제한자 같은 것도 있다.코드 리뷰를 하는데 이런 코드 스타일에 대해서 코멘트를 다는 시간을 줄이고 코드 리뷰를 더 효율적으로 도와줄 수 있는...", "content": "깃허브에서 PR을 올려서 코드 리뷰를 받고 있는데, 코드 리뷰를 하다 보면 코드 스타일 등에 대해서 놓친 경우가 있어서 코멘트를 다는 경우가 있다. 예를 들면 네이밍 컨벤션이 잘 지켜지지 않거나 자주 놓치는 접근 제한자 같은 것도 있다.코드 리뷰를 하는데 이런 코드 스타일에 대해서 코멘트를 다는 시간을 줄이고 코드 리뷰를 더 효율적으로 도와줄 수 있는 Danger가 있다. 이 글에서는 Danger가 무엇이고 GitHub Actions를 이용해서 PR을 올릴 때마다 코드 스타일이나 컨벤션을 체크할 수 있는 작업을 적용하는 방법을 소개하겠다.DangerDanger는 CI 프로세스에 실행하는 도구로, 코드 리뷰 관련 작업을 자동화 작업을 진행한다. Dangerfile이라는 파일을 가지고 어떤 동작을 수행할지 작성한 다음에 사용한다. GitHub, GitLab, Jenkins, Bitrise 등 지원하는 서비스가 많다. 나는 여기 중에서 GitHub Actions를 이용해서 PR을 올릴 때, Danger 작업을 실행하면서 코드 스타일에 대해서 검사하도록 추가하는 작업을 소개하겠다.GitHub ActionsDanger를 실행하는 방법 중에 하나는 GitHub Actions를 사용하는 것이다. GitHub Actions는 깃허브에서 제공하는 CI와 CD를 위한 서비스입니다. 깃허브에 있는 프로젝트 저장소에서 어떤 이벤트를 발생하면 어떤 동작을 실행하도록 한다. GitHub Action을 사용하려면 아래와 같이 워크플로우를 생성해야 한다. 깃허브 문서에도 자세히 설명되어 있어 참고하면 좋다. 작업하기 전에 신규 브랜치 생성해서 아래 작업을 진행하면 좋다. 깃허브 리파지토리에 .github/workflows 디렉토리를 생성한다. .github/workflows 디렉토리 안에 danger-swiftlint.yml 파일을 만든다. 파일 이름은 꼭 이 이름 사용 안 해도 괜찮다. 아래에 나와 있는 YAML 내용을 복사해서 아까 생성한 danger-swiftlint.yml 파일에 작성한다.// 1name: Danger-SwiftLinton: // 2 pull_request: branches: [ main, develop ]// 3jobs: build: runs-on: ubuntu-latest name: \"Run Danger\" steps: - uses: actions/checkout@v1 - name: Danger // 4 uses: docker://ghcr.io/danger/danger-swift-with-swiftlint:3.13.0 with: args: --failOnErrors --no-publish-check env: GITHUB_TOKEN: $파일에 대한 주요 설명은 아래와 같다. 각 코드에 대한 자세한 설명은 깃허브 문서를 참고하면 된다. 워크플로우 이름 워크플로우를 실행(trigger)할건지 정의한다. 여기서는 pull_request를 만들 때 마다 워크플로우를 실행할 것이고, 브랜치는 main, develop일 경우에 워크플로우가 실행될 것이다. 워크플로우에 실행할 작업들 Danger 작업을 진행할 때 어떤 것을 실행할지 정의한다. 여기서는 Danger + SwiftLint를 사용할 것이다.지금까지는 PR을 올렸을 때 깃허브 액션을 실행하는 워크플로우 파일을 생성했다. 이제는 워크플로우에서 Danger를 실행하라고 했으니, Danger를 통해서 어떤 작업을 수행할지 Dangerfile을 configure하는 작업이 필요하다.Dangerfile터미널을 이용해서 Dangerfile 파일을 생성하고 edit하는 명령어를 사용하면 된다. 아래와 같이 먼저 brew로 Danger를 설치한다.brew install danger/tap/danter-swift그리고 Dangerfile를 추가할 프로젝트 루트 경로에서 아래 터미널로 명령어를 친다. 아래 명령어를 치면 터미널에서 기다렸다가 Xcode로 Dangerfile을 생성하거나 편집하도록 열게 된다. 이때 터미널을 계속 열어둔다.danger-swift editXcode으로 열면 main.swift 파일을 열어서 Dangerfile 설정을 작성하면 된다.아래와 같이 Dangerfile을 구성하면 된다. 아래는 간단한 예제를 작성한 것이며, 다른 예제들을 참고하면서 프로젝트에 맞는 규칙들을 추가하면 된다.import Dangerlet danger = Danger()// Make it more obvious that a PR is a work in progress and shouldn't be merged yetif danger.github.pullRequest.title.contains(\"WIP\") { warn(\"PR is classed as Work in Progress\")}// Warn when there is a big PRif (danger.github.pullRequest.additions ?? 0) &gt; 500 { warn(\"Big PR, try to keep changes smaller if you can\")}// Run SwiftlintSwiftLint.lint(inline: true, configFile: \".swiftlint.yml\")그리고 나서 Xcode를 먼저 끈 후에, 안전하게 터미널에서 엔터를 치고 나온다. 현재까지 작업을 진행했다면 아래 두 가지 파일을 생성했을 것이다. github actions 파일 Dangerfile 파일관련 내용이 반영이 되었다면 작업한 내용을 push하고 PR을 올려서 리파지토리에 반영하도록 한다. 올바르게 작업을 했다면 PR을 생성한 순간 Danger가 실행할 것이다.SwiftLint 및 기타 pluginsSwiftLint는 스위프트 스타일과 컨벤션 등을 지키도록 도와주는 도구다. Danger SwiftLint plugin을 가지고 pr 올릴 때마다 체크해 줘서 막강한 힘을 보여준다. SwiftLint 말고도 다른 Danger plugin들도 있다. 예를 들어 빌드 정보를 보여주거나 테스트 코드들을 실행하는 등 다른 plugin들을 찾아보면서 프로젝트에 알맞은 도구를 사용하면 좋을 것 같다. Plugin들은 여기서 확인해 볼 수 있다.Conclusion초반에 적용할 때는 시행착오를 많이 겪었지만, 적용하고 나서는 코드 리뷰할 때 코드 스타일이나 컨벤션 등을 덜 신경 쓰고 코드에 더 집중할 수 있는 것을 느꼈다. 앞으로도 좋은 도구들이 있으면 사용해서 더 효율적인 코드 리뷰를 진행할 수 있도록 연구해볼 계획이다.참고Danger SwiftDanger Swift GitHubDanger plugins to speed up code reviewsAutomate PRs With Danger" }, { "title": "iOS 15에서 UIButton의 title이 Button으로 나타나는 현상 해결 방법", "url": "/posts/solve-ios15-button-title-showing/", "categories": "", "tags": "UIKit", "date": "2022-07-26 00:00:00 +0000", "snippet": "Xib로 UIButton을 만들면 보통 Type을 Custom으로 해서 만드는 경우가 있다. 이미지를 넣어서 이미지만 있는 버튼을 그릴 때는 Title 값을 빈 문자열로 둔다. 하지만 어떻게 설정하냐에 따라서 iOS 15에서는 Title 값에 Button이 나타나는 경우가 있다.이때는 Style 값을 Default 값으로 바꾼 뒤, Title 값을 지...", "content": "Xib로 UIButton을 만들면 보통 Type을 Custom으로 해서 만드는 경우가 있다. 이미지를 넣어서 이미지만 있는 버튼을 그릴 때는 Title 값을 빈 문자열로 둔다. 하지만 어떻게 설정하냐에 따라서 iOS 15에서는 Title 값에 Button이 나타나는 경우가 있다.이때는 Style 값을 Default 값으로 바꾼 뒤, Title 값을 지우면 해결이 된다.Xib 파일을 코드 상으로 확인했을 때, title=\"Button\"으로 되어 있는 게 없는지 체크하는 방법도 있다." }, { "title": "HTML을 NSAttributedString으로 변환하기", "url": "/posts/html-to-nsattributedstring/", "categories": "", "tags": "strings", "date": "2022-07-11 00:00:00 +0000", "snippet": "화면에 노출하는 데이터 중에 문자열을 다루는 데이터가 많다. 그중에 특정 문자열의 텍스트 스타일을 입혀서 보여주는 경우가 있는데, 보통 HTML을 가지고 포맷하는 경우가 많다. 이때, swift에서 HTML을 NSAttributedString으로 변환해서 보여줄 수 있다.예를 들어 아래와 같이 HTML이 있다면:\"&lt;b&gt;Hello&lt;/b&...", "content": "화면에 노출하는 데이터 중에 문자열을 다루는 데이터가 많다. 그중에 특정 문자열의 텍스트 스타일을 입혀서 보여주는 경우가 있는데, 보통 HTML을 가지고 포맷하는 경우가 많다. 이때, swift에서 HTML을 NSAttributedString으로 변환해서 보여줄 수 있다.예를 들어 아래와 같이 HTML이 있다면:\"&lt;b&gt;Hello&lt;/b&gt; World.\"문자열을 NSAttributedString으로 변환해서 UILabel이나 UITextView에 담으면 된다. 먼저 문자열을 Data 인스턴스로 변환한다.let data = Data(html.utf8)그러고 나서 NSAttributedString으로 변환한다. 변환하는 과정 중에 유효하지 않을 수 있기 때문에 try?를 사용한다.if let attributedString = try? NSAttributedString(data: data, options: [.documentType: NSAttributedString.DocumentType.html, .characterEncoding: String.Encoding.utf8.rawValue], documentAttributes: nil) { stringLabel.attributedText = attributedString}Extension자주 사용할 것 같다면, 변환하는 과정을 extension으로 만들어 사용할 수 있다.extension String { func asAttributedString() -&gt; NSAttributedString? { guard let data = self.data(using: .utf8) else { return nil }\t\t return try? NSAttributedString( data: data, options: [.documentType: NSAttributedString.DocumentType.html, .characterEncoding: String.Encoding.utf8.rawValue], documentAttributes: nil ) }}// Usagelet htmlString = \"&lt;p&gt;Hello, &lt;strong&gt;world!&lt;/strong&gt;&lt;/p&gt;\"label.attributedText = htmlString.asAttributedString()스타일 입히기HTML을 다루고 있기 때문에 CSS를 이용해서 텍스트 스타일을 입힐 수 있다. 스타일을 입힐 수 있는 HTML 코드를 작성해서 적용하면 된다. 색상과 폰트 사이즈도 조절하고 싶다면 파라미터를 사용해서 적용할 수도 있다.func asAttributedString(size: CGFloat, color: UIColor) -&gt; NSAttributedString? { let htmlTemplate = \"\"\" &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; body { font-family: -apple-system; font-size: \\(size)px; color: \\(color.hexString!); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; \\(self) &lt;/body&gt; &lt;/html&gt; \"\"\" guard let data = htmlTemplate.data(using: .utf8) else { return nil } guard let attributedString = try? NSAttributedString( data: data, options: [.documentType: NSAttributedString.DocumentType.html, .characterEncoding: String.Encoding.utf8.rawValue], documentAttributes: nil ) else { return nil } return attributedString}extension UIColor { var hexString:String? { if let components = self.cgColor.components { let r = components[0] let g = components[1] let b = components[2] return String(format: \"#%02x%02x%02x\", (Int)(r * 255), (Int)(g * 255), (Int)(b * 255)) } return nil }}// Usagelabel.attributedText = htmlString.asAttributedString(size: 18, color: .systemBlue)주의점주의해야할 점은 initializer를 호출할 때는 메인 쓰레드에서 호출해야 한다. The HTML importer should not be called from a background thread (that is, the options dictionary includes documentType with a value of html). It will try to synchronize with the main thread, fail, and time out. Calling it from the main thread works (but can still time out if the HTML contains references to external resources, which should be avoided at all costs). The HTML import mechanism is meant for implementing something like markdown (that is, text styles, colors, and so on), not for general HTML import. From Apple Documents참고How to display HTML in UILabel and UITextView" }, { "title": "2022 상반기 회고", "url": "/posts/2022-the-first-half-retrospect/", "categories": "", "tags": "restrospect", "date": "2022-07-04 00:00:00 +0000", "snippet": "벌써 1년의 반이 지나갔다. 원래는 연말마다 1년 회고를 쓰려고 했는데, 요즘 주간 회고를 하고 있고 회고의 중요성을 많이 깨닫고 있어서, 늦게나마 상반기 회고를 작성하게 되었다.앱 용량, 빌드 속도 줄임한 프로젝트를 4년 넘게 보니깐 해결해야 하는 숙제들이 많이 쌓여갔었다. 프로젝트가 운영한지 오래되기도 했고, 앞으로도 더 많은 개발자들이 함께할 예...", "content": "벌써 1년의 반이 지나갔다. 원래는 연말마다 1년 회고를 쓰려고 했는데, 요즘 주간 회고를 하고 있고 회고의 중요성을 많이 깨닫고 있어서, 늦게나마 상반기 회고를 작성하게 되었다.앱 용량, 빌드 속도 줄임한 프로젝트를 4년 넘게 보니깐 해결해야 하는 숙제들이 많이 쌓여갔었다. 프로젝트가 운영한지 오래되기도 했고, 앞으로도 더 많은 개발자들이 함께할 예정이었기에, 가장 빠르게 해결할 수 있는 것을 했다. 바로 레거시 코드 정리하는 것.미사용하는 코드, 파일, asset 같은 것들을 추적해서 하나씩 지워가면서 정리를 했는데, 작업하는 시간만 계산하면 2일 정도 걸린 것 같다. 지우고 나서 프로젝트 빌드 및 실행해서 앱 크래시가 발생하지 않는지 체크를 했어야 했다. 생각보다 미사용하는 코드들도 있었고, 언젠가 다시 원복하게 되지 않았을까 하고 남겨둔 파일이나 코드들이 있었다. 그나마 프로젝트를 오래 본 사람이 나여서 쓰이고 있는 코드인지 아닌지 알 수가 있어서, 큰 불안감 없이 작업을 진행했다. 그리고 나서의 결과는 생각보다 좋았다.앱 파일 크기가 130.3MB에서 76.7MB으로 줄이고, 프로젝트 빌드 시간을 약 80초 줄이고, Fastlane 기준으로 빌드 및 배포하는 시간이 20분에서 7-8분으로 줄어들었다. 레거시 코드만 정리한걸로 생각보다 좋은 결과를 받아서 뿌듯했다. 단순하게 파일 정리만해도 이 정도의 결과를 받아서, 조금 더 개선할 수 있는 것을 해보고 정리하여 회사 기술 블로그에 글 쓰려고 계획하고 있다.약 10주 동안의 야근같이 협업하는 개발자가 나가게 되면서, 나와 주니어 개발자는 그분이 작업한 내용을 대응하고 코드 다시 정리하느라 야근을 오래 했다. 정말 오랜만에 아주 길게 야근을 한 것 같다. 이 기간 동안에는 택시 타면서 퇴근했는데, 어쩌다 한번 지하철 타고 퇴근하면 되게 어색했었다. 어쩔 수 없는 상황이기에 불만이나 불평을 크게 내지 않고 일을 진행했는데, 혹시나 주니어 개발자는 이 상황이 불편하거나 싫어할까 봐 걱정이 앞섰다. 다행히 어른스럽게 생각을 했고, 하나의 경험이다 하고 좋게 생각해 줘서 조금 고마웠다. 앞으로는 직접적으로 주니어 개발자를 지도하면서 개발은 못 하지만, 더 성장할 거라는 확신이 이때 들었다.아무래도 오래 야근하게 되면 몸이 지치고 마음도 지치게 되는 것 같다. 회사도 오래 다녔는데, 리프레쉬 휴가 같은게 없어서 쉬고 싶은 시기에, 갑자기 야근으로 인해 힘들어지니깐 더 쉬고 싶었던 마음이 커졌다. 휴직을 너무나 하고 싶었고, 그냥 아무 생각 없이 쉬고 싶었다. 지금은 좀 힘든 시기를 지나가서 괜찮지만, 그래도 여전히 길게 쉬고 싶은 마음은 남아 있다.코드 리뷰 활성화꽤 몇 개월 동안 회사의 불만점에 소스코드 관리 서비스가 너무 안 좋다고 작성했다. 우선 PR를 작성하는 게 다른 소스코드 관리 서비스에 비해 기능이 너무 없고, 코드 리뷰할 때 코멘트를 달거나 병합을 하지 않게 하는 등 기능이 너무 없거나 불편해서 불만이 많았다. 이 불만이 결국 윗사람(?)까지 가게 되어서 이야기를 하고, 시범적으로 다른 소스코드 관리 서비스 사용할 수 있게 해주셨다. 지금도 너무 감사하게 생각하고 있다.그러면서 평소에 해보고 싶었던 코드 리뷰 관련 규칙이나 방법을 도입하는 시도를 했다. 가장 먼저 도입한 것은 짧은 PR를 올리는 것이다. 코드 리뷰하는 시간이 너무 길면 집중이 떨어질 수 있고, 시간도 많이 소요될 수 있다. 그래서 기능 단위, 이슈 단위로 짧은 PR 올리도록 규칙을 정하고 같이 협업하는 개발자랑 같이 진행하도록 했다. 처음에는 기능을 더 쪼개서 짧은 단위의 PR를 올릴 수 있을까 걱정했는데, 조금씩 노력하다 보니깐 너무 길지 않는 PR들이 많이 나오기 시작했다.그 다음에는 코드 리뷰하는 시간을 업무 시간에 확보하는 것이다. 출근해서 30분, 오후에 30분 이렇게 특정 시간에 코드 리뷰하는 시간을 가지도록 했다. 온라인으로 올라온 PR를 코드 리뷰하는 건데, 이렇게 확보된 코드 리뷰하는 시간이 있으니깐, 그 시간 전까지 PR을 올리도록 작업하거나 내 PR이 코드 리뷰하고 병합하는데 오래 안 걸리겠다는 안도감이 생겼다. 앞서 얘기한 짧은 PR 올리는 거랑 시너지 효과가 좋아서 아주 빠르게 코드 리뷰를 하고 병합해서 다음 작업 진행할 수 있게 되었다.그 다음에는 CI/CD를 이용해서 코드 컨벤션을 체크하거나 테스트를 돌리게 하는 것이고, 그 외에도 좋은 코드 리뷰하는 프로세스가 있으면 조금씩 도입하려고 한다.하반기 계획프로젝트에 기여할 수 있는 여러 가지 방법들을 찾아보고 하나씩 실천하려고 한다. 나에게 주어진 업무 외에도 알아서 할 수 있는 것들 중에 골라서 업무를 하고 있기 때문에 무엇을 더 해야 하는지 고민할 필요가 없다. 파트장님도 내가 스스로 업무를 가져가거나 업무를 하는 것을 알고 있어서 굳이 신경을 쓰고 있지 않는 것 같다. 다만, 현재 회사가 많은 변화를 겪고 있어서, 거기에 따라 내 역할(?)도 사라진 것도 있어, 이 부분에 대해서 가이드를 해달라고 요청했다. 파트장님도 새로운 변화에 맞춰서 어떻게 파트를 운영할지 고민이어서, 특별히 다른 업무를 줄 때까지 기다릴 예정이다.틈틈이 SwiftUI랑 Combine, Async/Await를 공부할 예정이다. 사실 스위프트 문법을 다시 복습하는 시간을 가지는 게 우선인데, 상반기에는 너무나 많은 힘든 일이 생겨서 내 몸이랑 마음 회복하는 시간을 더 투자했다. 회복하는 시간을 가져야 다시 뛸 수 있기 때문이다. 틈틈이 운동을 하면서 체력을 기르면서 우울감을 씻는 효과를 보고 있고, 사소하게 행복감을 느끼는 것들을 기록하려고 노력하고 있다. 이제 조금 회복된 것 같아서 멈췄던 블로그 글 쓰는 것도 다시 시작하려고 한다.상반기에는 개인적으로 많은 힘든 일이 생기면서 다시 생각해보면 그 사이에도 행복했던 순간들이 있었던 것 같다. 하반기에는 힘든 일이 없을 순 없겠지만, 그 사이에 소소한 행복들도 느낄 수 있는 시간들이 있었으면 좋겠다." }, { "title": "SwiftUI에서 contentShape()을 이용해서 뷰를 탭하게 하는 방법", "url": "/posts/swiftui-tappable-area-using-contentshape/", "categories": "", "tags": "swiftui", "date": "2022-05-09 00:00:00 +0000", "snippet": "일반 Text나 Image을 사용하면 탭 제스처를 추가해서 탭 했을 때의 동작을 정의할 수 있다. 하지만 VStack이나 HStack 같은 container view에 제스처를 추가하면 생각처럼 잘 안될 때가 있다. 예를 들어, HStack 안에 Image와 Text 사이에 Spacer를 넣었다면, Spacer 영역을 탭 했을 때, 원하는 탭 제스처가...", "content": "일반 Text나 Image을 사용하면 탭 제스처를 추가해서 탭 했을 때의 동작을 정의할 수 있다. 하지만 VStack이나 HStack 같은 container view에 제스처를 추가하면 생각처럼 잘 안될 때가 있다. 예를 들어, HStack 안에 Image와 Text 사이에 Spacer를 넣었다면, Spacer 영역을 탭 했을 때, 원하는 탭 제스처가 안 될 때가 있다.이럴 때, contentShape()을 이용해서 탭 영역을 잡으면 가능하게 할 수 있다. 아래 코드와 같이 HStack에 contentShape() modifier를 추가하면 stack 전체를 탭 가능한 영역으로 만들 수 있다.HStack { Text(\"Terms\") Spacer() Image(systemName: \"chevron.right\")}.contentShape(Rectangle()).onTapGesture { print(\"Show details for terms\")}" }, { "title": "UserDefaults를 사용하는 방법", "url": "/posts/how-to-use-userdefaults/", "categories": "", "tags": "userdefaults, foundation", "date": "2022-04-11 00:00:00 +0000", "snippet": "iOS에서는 사용자 설정 같이 정보량이 적은 데이터들을 앱이 설치되어 있는 동안 저장하여 사용할 수 있습니다. 바로 UserDefaults를 사용해서 저장하는 방법입니다. UserDefaults는 integer, boolean, string, array, dictionary, URL 같은 타입들을 저장할 수 있습니다.let defaults = User...", "content": "iOS에서는 사용자 설정 같이 정보량이 적은 데이터들을 앱이 설치되어 있는 동안 저장하여 사용할 수 있습니다. 바로 UserDefaults를 사용해서 저장하는 방법입니다. UserDefaults는 integer, boolean, string, array, dictionary, URL 같은 타입들을 저장할 수 있습니다.let defaults = UserDefaults.standarddefaults.set(30, forKey: \"Age\")defaults.set(\"JooHee\", forKey: \"Name\")defaults.set(false, forKey: \"NotificationAllowed\")let array = [\"Apple\", \"Banana\"]defaults.set(array, forKey: \"Fruits\")let dict = [\"Name\": \"Joohee\", \"Country\": \"KOR\"]defaults.set(dict, forKey: \"UserInfoDict\")이와 같이 데이터들을 저장하면 영구적으로 저장이 됩니다. 즉, 앱을 다시 켰을 때도 저장했을 때와 똑같은 정보가 저장되어 있습니다. 저장한 데이터들을 다시 읽을 때도 쉽게 할 수 있습니다.let age = defaults.integer(forKey: \"Age\")let isNotificationAllowed = defaults.bool(forKey: \"NotificationAllowed\")let name = defaults.string(forKey: \"Name\")다만, 만약 저장되어 있는 데이터가 없다면 UserDefaults에서는 default value를 리턴합니다. 실제로 저장한 데이터와 기본값을 구분하기 위해서 어떤 기본값을 리턴하는지 유의해서 사용해야 합니다. integer(forKey:): returns 0 double(forKey:): returns 0 bool(forKey:)* returns false string(forKey:): returns nil object(forKey: String): returns Any?위 string과 object 경우에는 옵셔널한 값이 리턴됩니다. 옵셔널 값을 받으면 원하는 데이터 타입으로 타입 변환해서 사용해야 합니다. 비어 있는 값이면 기본적으로 사용할 값을 ?? 연산자(nil coalescing operator)를 이용해서 지정합니다.let savedFruits = defaults.object(forKey: \"Fruits\") as? [String] ?? [String]()UserDefaults에 저장된 값을 지우고 싶을 때는 removeObject(forKey:) 메소드를 사용합니다.defaults.removeObject(forKey: \"Age\")UserDefaults는 싱글톤이고 thread-safe입니다.참고https://developer.apple.com/documentation/foundation/userdefaults" }, { "title": "Xcode Playground에서 attach failed invalid argument 에러 해결하는 방법", "url": "/posts/xcode-playground-attach-failed-error/", "categories": "", "tags": "swift playground, developer tools", "date": "2022-04-04 00:00:00 +0000", "snippet": "Xcode Playground 생성해서 간단한 코드를 실행하려고 하는데, 아래와 같이 에러가 발생해서 실행이 안 되는 것을 발견했다. Failed to launch process. Failed to attach to stub for playground execution: error: attach failed ((os/kern) invalid argu...", "content": "Xcode Playground 생성해서 간단한 코드를 실행하려고 하는데, 아래와 같이 에러가 발생해서 실행이 안 되는 것을 발견했다. Failed to launch process. Failed to attach to stub for playground execution: error: attach failed ((os/kern) invalid argument).에러가 발생한 이유는 Xcode를 ‘Rosetta를 사용하여 열기’ 설정을 활성화해서 발생했다. 해당 설정을 비활성화하니깐 에러가 발생하지 않았다.참고Xcode Playground Failed to launch" }, { "title": "문자열 배열을 하나의 문자열로 결합하는 방법", "url": "/posts/how-to-join-string-array-to-single-string/", "categories": "Tips", "tags": "strings", "date": "2022-03-27 00:00:00 +0000", "snippet": "스위프트에서 문자열 배열을 하나의 문자열로 결합하는 간단한 메소드가 있습니다. 바로 joined()입니다.let array = [\"고양이\", \"강아지\", \"햄스터\"]let joined = array.joined(separator: \", \")print(joined)// Prints \"고양이, 강아지, 햄스터\"separator 파라미터를 이용해서 합쳐지는...", "content": "스위프트에서 문자열 배열을 하나의 문자열로 결합하는 간단한 메소드가 있습니다. 바로 joined()입니다.let array = [\"고양이\", \"강아지\", \"햄스터\"]let joined = array.joined(separator: \", \")print(joined)// Prints \"고양이, 강아지, 햄스터\"separator 파라미터를 이용해서 합쳐지는 요소들 사이에 넣고 싶은 문자열을 추가할 수 있습니다.joined(separator:)" }, { "title": "Custom URL Scheme를 시뮬레이터에서 빠르게 여는 방법", "url": "/posts/open-custom-url-scheme-on-simulator-faster/", "categories": "Xcode", "tags": "xcode", "date": "2022-01-31 00:00:00 +0000", "snippet": " 해당 글은 Quick way to open a Custom URL Scheme in iOS Simulator 참고하여 작성한 글입니다.애플에서 커스텀 URL 스키마(이하 custom URL scheme)를 이용하여 앱의 특정 페이지를 여는 방법을 제공합니다. 특정 custom URL scheme을 탭 하면 앱이 열리게 되는데, 테스트하는 방법은 주...", "content": " 해당 글은 Quick way to open a Custom URL Scheme in iOS Simulator 참고하여 작성한 글입니다.애플에서 커스텀 URL 스키마(이하 custom URL scheme)를 이용하여 앱의 특정 페이지를 여는 방법을 제공합니다. 특정 custom URL scheme을 탭 하면 앱이 열리게 되는데, 테스트하는 방법은 주로 메모 앱에 custom URL scheme 주소들을 저장해서 누르는 방식으로 테스트했습니다. 혹은 사파리에서 직접 주소를 입력하여 앱을 실행했습니다. 사파리에서 직접 입력하거나 메모 앱에서 하나씩 눌러서 테스트해도 괜찮으나, custom URL scheme이 너무 많을 경우 하나씩 확인하는 작업이 귀찮거나 느릴 수 있습니다.터미널 명령어를 이용해서 시뮬레이터에서 열기Xcode 안에 있는 도구를 사용할 수 있는 command line인 xcrun을 사용하면, 시뮬레이터에서 빠르게 custom URL scheme을 열 수 있습니다.xcrun simctl openurl booted {custom URL Scheme}마무리시뮬레이터에서 빠르게 명령어를 이용해서 custom URL scheme를 여는 방법을 알아보았습니다. 저는 개인적으로 명령어를 사용하니깐 더 빠르게 테스트해서 좋았습니다. 관련하여 애플에서 작성한 Defining a Custom URL Scheme for Your App 글도 참고하면 좋을 것 같습니다.Xcode 관련 글을 더 보고 싶다면 Xcode 카테고리 페이지를 확인해 볼 수 있으며, 질문이나 피드백이 있다면 트위터 혹은 이메일로 연락 주세요.글 읽어주셔서 감사합니다." }, { "title": "UIPageViewController의 transitionStyle이 scroll일 경우, 크래시가 나는 버그 해결", "url": "/posts/uipageviewcontroller-scroll-animated-crash/", "categories": "", "tags": "iOS, bugfix", "date": "2022-01-24 00:00:00 +0000", "snippet": "이상하게 iOS 15에서 특정 페이지로 스크롤 할 때, 크래시가 발생하는 일이 생겼습니다. iOS 15 미만 기기에서는 발생하지 않았는데, iOS 15에서만 발생하여 iOS 15에서만 UIPageViewController가 내부적으로 특이하게 동작하는 것 같았습니다. 크래시가 발생하는 부분은 아래 코드 부분이었습니다.setViewControllers:...", "content": "이상하게 iOS 15에서 특정 페이지로 스크롤 할 때, 크래시가 발생하는 일이 생겼습니다. iOS 15 미만 기기에서는 발생하지 않았는데, iOS 15에서만 발생하여 iOS 15에서만 UIPageViewController가 내부적으로 특이하게 동작하는 것 같았습니다. 크래시가 발생하는 부분은 아래 코드 부분이었습니다.setViewControllers:direction:animated:completion:검색하다 보니 UIPageViewController가 scroll type이면서 animation을 true로 할 경우, 내부 캐시 문제로 버그가 발생한다며 예전부터 있었던 버그인 것으로 보입니다 (스택오버플로우). 여기서 해당 버그를 수정하는 방법이 2가지가 있습니다. UIPageViewControllerTransitionStyleScroll을 사용하지 않는다 setViewControllers:direction:animated:completion: 을 호출할 때, animated을 false으로 지정한다.아예 안 쓰는 거는 다른 페이지들도 영향이 가기 때문에, 2번째 방법을 사용하여 버그를 해결했습니다.참고UIPageViewController navigates to wrong page with Scroll transition style" }, { "title": "SwiftUI에서 NavigationView 사용하기", "url": "/posts/swiftui-navigationview/", "categories": "", "tags": "swiftui", "date": "2022-01-03 00:00:00 +0000", "snippet": "NavigationViewSwiftUI에서 NavigationView를 이용해서 유저가 navigate 하면서 여러 화면들을 이동할 수 있게 할 수 있습니다. 아래 예시 코드에서 Text를 NavigationView로 감쌌는데, 감싼 후에 Text가 아래로 이동한 것을 볼 수 있습니다.struct ContentView: View { var bod...", "content": "NavigationViewSwiftUI에서 NavigationView를 이용해서 유저가 navigate 하면서 여러 화면들을 이동할 수 있게 할 수 있습니다. 아래 예시 코드에서 Text를 NavigationView로 감쌌는데, 감싼 후에 Text가 아래로 이동한 것을 볼 수 있습니다.struct ContentView: View { var body: some View { NavigationView { Text(\"Hello, SwiftUI\") } }} NavigationView가 없는 Text NavigationView가 있는 Text 하지만 네비게이션의 타이틀 영역에 아무것도 안 나타나고 있습니다. 네비게이션의 타이틀을 보여주고 싶다면 navigationTitle(_:) modifier를 사용해야 합니다.NavigationTitle네비게이션의 타이틀은 navigationTitle modifier를 사용하는데, NavigationView의 괄호 바깥에서 지정하는 게 아닌, 안쪽에서 지정해야 합니다.// Right UsageNavigationView { Text(\"Hello, SwiftUI\") .navigationTitle(\"SwiftUI\")}// This does nothingNavigationView { Text(\"Hello, SwiftUI\")}.navigationTitle(\"SwiftUI\")NavigationView 안에 보이고 있는 view의 타이틀을 지정하기 위해서 위에서 Text view에 navigationTitle를 지정합니다. 만약 NavigationView에 navigationTitle를 지정하면 고정적인 타이틀을 지정하는 의미로 볼 수 있습니다.NavigationLink네비게이션을 사용하는 이유는 그다음 화면으로 이동하거나 이동한 이후에 전 화면으로 되돌아가거나 등, 유저가 앱을 사용하면서 다양한 화면 이동을 할 수 있도록 하기 위해서입니다. 유저는 SwitUI에서 NavigationView에서 다음 이동할 화면을 가기 위해서는 NavigationLink를 선택하여 이동합니다.아래는 다음 화면을 보여주기 위해 텍스트와 색상을 받아서 화면을 그리는 SecondView 입니다. 여기서 navigationTitle를 이용해서 네비게이션의 타이틀을 보여주고, ZStack을 이용해서 배경색을 지정하고 그 위에 텍스트를 배치했습니다.struct SecondView: View { var text: String var color: Color var body: some View { ZStack { color Text(text) .font(.body) } .navigationTitle(text) }}List 안에 NavigationLink를 이용해서 3개의 항목을 만들고, 각 destination이 SecondView로 이동하도록 합니다. NavigationLink는 Label과 Destination이 필요한데, destination은 이동할 view를 뜻하고 label은 destination으로 이동할 레이블을 뜻합니다.struct NavigationLink&lt;Label, Destination&gt; where Label : View, Destination : ViewNavigationView { List { NavigationLink(\"First\", destination: SecondView(text: \"First\", color: .red)) NavigationLink(\"Second\", destination: SecondView(text: \"Second\", color: .green)) NavigationLink(\"Third\", destination: SecondView(text: \"Third\", color: .blue)) } .navigationTitle(\"SwiftUI\")}마무리SwiftUI에서는 간단하게 NavigationView를 이용해서 유저가 앱을 navigate하면서 화면 이동을 할 수 있게 해줍니다. NavigationLink를 이용해서 다음 화면(destination)을 지정하고, navigationTitle(_:) modifier를 이용해서 타이틀을 지정할 수 있습니다.SwiftUI 관련 글을 더 보고 싶다면 스위프트UI 카테고리 페이지를 확인해 볼 수 있으며, 질문이나 피드백이 있다면 트위터 혹은 이메일로 연락 주세요.글 읽어주셔서 감사합니다." }, { "title": "2021년 회고", "url": "/posts/2021-annual-review/", "categories": "Blog", "tags": "blog", "date": "2021-12-30 00:00:00 +0000", "snippet": "벌써 2021년이 끝나간다. 시간이 빨리 지나간 것처럼 올해는 정말 많은 일이 있었고 바쁘게 지나간 것 같다. 작년에는 3년의 개발 생활을 회고했는데, 올해는 개인적인 일들이랑 같이 회고하려고 한다.일과 개발, 스터디회사 일은 늘 바쁘다. 빠르게 성장하고 더 높게 뛰기 위해 급하게 혹은 빠르게 개발해야 하는 일들이 있었다. 지금은 스쿼드 체계로 운영하...", "content": "벌써 2021년이 끝나간다. 시간이 빨리 지나간 것처럼 올해는 정말 많은 일이 있었고 바쁘게 지나간 것 같다. 작년에는 3년의 개발 생활을 회고했는데, 올해는 개인적인 일들이랑 같이 회고하려고 한다.일과 개발, 스터디회사 일은 늘 바쁘다. 빠르게 성장하고 더 높게 뛰기 위해 급하게 혹은 빠르게 개발해야 하는 일들이 있었다. 지금은 스쿼드 체계로 운영하고 있고, 하나의 프로젝트에만 집중할 수 있어 꽤 체계적으로 프로세스에 맞게 진행하고 있다. 같이 협업하는 개발자뿐만 아니라 디자이너, QA, PM 외 다른 사람들과 같이 문제를 해결해 나가는 프로세스도 어느 정도 정착이 되고 있다.하나의 프로젝트에 집중하게 되니깐 프로젝트의 기술 부채들을 조금씩 해결하고 있다. 주요 기능 개발은 같이 협업하는 주니어 개발자한테 맡기고 나는 주로 프로젝트 리팩토링 및 레거시 코드들을 정리하고 있다. 더 개선할 수 있는 부분들이 아직 남았지만, 그래도 꽤 레거시 코드들을 정리했다. 장기적으로 진행해야 하지만, 언젠가는 renew할 프로젝트를 위해서 꾸준히 하고 빨리 끝내고 싶다.하반기부터 iOS 파트에서 매주 스터디를 진행하고 있다. 예전부터 스터디 관련해서 진행하고 싶었는데, 첫 번째 SwiftUI 스터디 끝나고 두 번째 Combine 스터디를 진행하게 되었다. 스터디의 목표는 같이 협업하는 개발자들의 성장과 실무 프로젝트에 기술 도입인데, 스터디가 잘 마무리되어서 두 개의 목표가 이뤄졌으면 좋겠다.블로그블로그 글을 올해도 꾸준히 쓰려고 노력했다. 매주 글 하나씩 쓰던 시기가 있었는데, 역시 일이 많아지면 글을 쓸 수가 없었다. 글감은 항상 있어서 괜찮지만 막상 또 쓰려고 하면 귀찮아지고 더 잘 쓰기 위해 자료를 더 찾는 시간이 소요된다. 그러면 자연스럽게 글을 미루게 된다. 내년에는 이런 일이 덜 생기도록 조금씩 글을 쓸 때 미리 준비하면서 글을 써야겠다.블로그 운영한지 이제 2년이 다 돼가는데, 우연히 구글 애널리틱스에 봤는데 조회수가 높게 나오는 글이 있었다. 지금도 여전히 조회수가 높고 구글에 검색하면 내 글이 보인다. 아직 한참 멀었지만, 언젠가는 내 블로그 글도 많이 찾게 되도록 블로그를 잘 운영해야겠다.올해도 회사 기술 블로그 글을 쓰고 iOS 파트 내에서도 노션에 개발하다가 이슈 해결한 것들이나 공부한 것들을 소소하게 글을 쓰고 기록하고 있다. 개인 블로그 외에도 회사 내부에도 글을 많이 쓴 것 같다. 기록을 항상 중요하게 생각하고 있기 때문에, 이런 글들이 차곡차곡 쌓여서 도서관처럼 다양하고 도움이 되는 글들이 많이 생겼으면 좋겠다.여행과 건강가까운 친구가 올해 결혼했다. 그래서 결혼 전에 친구들이랑 다 같이 봄에 제주도 여행을 갔는데, 제주도에도 벚꽃이 예쁘게 피는 줄 몰랐다. 덕분에 봄이 되면 벚꽃 보러 제주도 가야겠다고 다짐을 했다. 그리고 여름에는 가족들이랑 같이 제주도 여행 갔는데, 거의 10년 만에 가족 여행을 갔다. 그동안 바쁘기도 했고 다 같이 여행 갈 수 있는 상황이 아니었는데, 어느 정도 여유가 생겨서 바로 가족 여행을 계획하고 진행했다. 부모님들도 편안하게 여행을 즐겼고 맛있는 음식들을 많이 먹었다. 서귀포 칼호텔에서 마일리지로 좋은 객실 예약해서 호화롭게 즐겼다. 다음에도 기회가 있다면 남해 혹은 다른 지역으로 가족 여행 가고 싶다.올 초에 스트레스를 너무 받았는지, 여름에 오른쪽 머리 밑에 작게 원형 탈모가 생겼다. 처음 발견했을 때 놀랐고 충격이 컸다. 피부과 다니면서 탈모 주사도 맞고 약도 챙겨 먹어서 지금은 많이 나아졌다. 탈모 주사는 너무 아팠고, 한 번만 맞는 게 아니고 여러 번 맞았다. 내가 이렇게까지 스트레스 많이 받았구나 깨달았고 내 몸 건강히 챙겨야겠다고 다짐했다. 재택근무로 인해 활동량이 줄어들었지만, 내년에는 본격적으로 운동을 꾸준히 할 수 있도록 해야겠다.야근하는 횟수는 많이 줄었지만, 신경 쓰이는 게 많아져서 가만히 있어도 스트레스 받는 게 느껴졌다. 아는 만큼 보인다고, 이전에 안 보이던 게 보이기 시작하고, 그로 인해 생각이 많아졌다. 어떻게 하면 해결할 수 있을지, 내가 해결할 수 있는 문제인지 등 고민을 엄청 많이 했다. 고민한 것을 해결하면서 풀었던 적도 있지만, 그래도 해결이 안 되는 문제들이 남아있다. 생각을 덜어야 하는데 그게 쉽지 않다. 눈치 보게 되고, 주변에서 나를 보는 시선 혹은 평가 등을 더 신경 쓰게 되었다. 그럼에도 불구하고, 늘 나는 당당하게 일을 하고 있고, 더 좋은 퀄리티를 위해서 열심히 하고 있다. 생각을 덜고 스트레스를 덜 받을 수 있게 환경을 만들거나 관리를 해야겠다.아주 작지만 다양한 외부와의 접촉(?)올해는 크지는 않지만 외부(?)에서 다양하고 소소한 일들이 있었다. 강의 전문 사이트에서 동영상 강의 제의도 왔었고, 가끔 보던 블로그의 개발자한테 이메일 와서 개발 관련된 내용을 주고받았다. 강의는 아쉽게 진행 못했지만 제의가 왔었다는 게 신기했고, 이 계기로 개인적인 목표가 생겨서 진행하고 있다.가끔 영어로 블로그 쓰는데, 그중 하나는 팔로우하고 있는 외국 개발자한테 눈에 띄어 내 글을 다른 개발자 글과 함께 소개하는 일이 있었다. 버킷리스트 중 하나였는데, 앞으로도 더 열심히 글을 잘 써야겠다는 생각이 들었다.처음 트위터를 시작했을 때는 유명한 해외 iOS 개발자들 팔로우하면서 정보를 얻으려고 했었는데, 올해는 한국 개발자들도 조금씩 팔로우하기 시작했다. 아직 트위터에서 혼잣말하는 게 쑥스럽고 뭔가 먼저 말을 거는 게 어렵지만, 조금씩 용기를 가지고 도전해 보려고 한다.성장 및 평가나는 항상 더 나은 개발자가 되려고 노력하고 있다. 꾸준히 공부하려고 하고, 공부한 내용을 프로젝트에 도입하려고 한다. 올해는 그래도 꽤 나름대로 다양하게 적용을 한 것 같다. 빌더 패턴을 이용해서 모달 팝업을 그리는 빌더를 만들어 보고, 코드가 잘 읽히도록 액션 타입을 만들어서 확실하게 어떤 액션을 하는지 알 수 있게 했다. 화면을 그리는 작업을 화면 상태에 따라서 분리하여 작업할 수 있도록 해봤고, Fastlane도 조금 만져 보았다. 확실히 작년보다 코드 작성하는 스타일 혹은 방법이 다양했고 많아졌다.올해 상사 몇 분이 나한테 부사수가 일 잘한다고 칭찬해 줬는데, 괜히 기분 좋고 뿌듯했다. 힘든 시기를 같이 지냈는데, 여유롭지 못한 상황에서도 내가 부사수를 잘 교육했고, 그 부사수도 잘 커서 다행이다. 지금 같이 일하고 있는 주니어 개발자도 매 차수마다 성장하고 있는 게 보이고 있다. 아직 다양한 업무를 보지 못해서 최대한 프로젝트의 이해도를 높이기 위해 업무를 주고 있다. 언젠가 같이 일하는 주니어 개발자도 비슷한 칭찬 받고 더 성장했으면 좋겠다.같이 일했던 개발자분께서 나를 칭찬하며 많이 성장했다고 다른 사람들 통해서 듣게 되었다. 꾸준히 공부하려고 하고 코드를 보면 성장한 게 많이 보였다고 했다. 사실 나도 같이 일했던 개발자한테 자극받아서 더 공부하고 더 좋은 코드 짜보려고 노력했다. 실제로 코드가 좋아졌는지, 개발자로서 성장했는지 객관적으로 보거나 직접적으로 들은 적이 없어서 조금 의기소침해 있고 자존감이 떨어진 적도 많았다. 하지만 같이 일했던 개발자의 말 덕분에 내가 진짜로 성장했구나 하고 깨달았고 안심이 들었다. 같이 일했던 개발자한테 다시 한번 감사하고, 다른 곳에서도 좋은 일과 즐거운 개발을 하길 응원한다.매일 1% 성장하는 개발자내년이면 5년 차 개발자가 되는데, 연차가 가지는 그 무게감이 점점 무거워지고 있다. 나는 과연 그 연차만큼 개발을 잘 하고 있는지, 만약 다른 기회가 생긴다면 그만큼 잘할 자신이 있는지 두렵다. 점점 더 커지는 벽이 다가오고 있다. 이 벽도 잘 깨트리기 위해서 뼈와 살을 깎는 노력을 해야겠다고 생각이 든다.예전에는 천재 같은 개발자가 되고 싶었는데, 이제는 생각과 마음가짐을 다르게 가졌다. 그냥 적당히 잘하는 개발자. 욕심을 더 부리다가 더 내 스스로한테 너무 힘들게 할 것 같아서, 천재가 아닌 적당히 잘하는 개발자가 되자.작년에는 더 나은 코드, 더 나은 개발자로 성장하고 싶다고 했는데, 조금씩 그러고 있다는 게 느끼고 있다. 여전히 읽기 좋은 코드를 작성하는 거랑 앱의 퀄리티를 높이는 개발자이고 싶다. 이제는 어제보다 나은, 1%씩 성장하는 개발자가 되려고 한다. 매일 1%씩 성장한다면, 1년이면 365% 성장하는 거다. 내년 연말에도 그만큼 성장하기를 기대해 본다." }, { "title": "SwiftUI에서 View에 Background 추가하기", "url": "/posts/swiftui-add-background/", "categories": "", "tags": "swiftui", "date": "2021-12-27 00:00:00 +0000", "snippet": "View에 Background 더하기스위프트UI에서 background(_:alignment:) view modifier를 이용해서 view에 background를 추가할 수 있습니다. 백그라운드는 추가하는 뷰의 크기만큼 만들어집니다.struct ContentView: View { let background = Color.blue var b...", "content": "View에 Background 더하기스위프트UI에서 background(_:alignment:) view modifier를 이용해서 view에 background를 추가할 수 있습니다. 백그라운드는 추가하는 뷰의 크기만큼 만들어집니다.struct ContentView: View { let background = Color.blue var body: some View { VStack { Image(systemName: \"globe\") .imageScale(.large) .foregroundColor(Color.green) Text(\"Hello, world!\") .foregroundColor(Color.white) .background(background) } }}백그라운드를 추가할 때, 어떤 뷰에 background(_:alignment:) modifier를 추가하냐에 따라 그려지는 모습이 달라집니다. 아래는 VStack에 백그라운드를 추가한 모습입니다.var body: some View { VStack { Image(systemName: \"globe\") .imageScale(.large) .foregroundColor(Color.green) Text(\"Hello, world!\") .foregroundColor(Color.white) } .background(background)}더 넓은 백그라운드 만들기만약 더 넓게 백그라운드를 더하고 싶으면, ZStack 안에 View를 넣고 백그라운드 뷰를 넣으면 됩니다. 그러면 그 백그라운드는 그리는 뷰 넘어서 크게 그려집니다. 하지만, 기본적으로 safe area 영역을 침범하지 않을 정도로 채웁니다.var body: some View { ZStack { background VStack { Image(systemName: \"globe\") .imageScale(.large) .foregroundColor(Color.green) Text(\"Hello, world!\") .foregroundColor(Color.white) } }}Safe Area까지 백그라운드 넓히기기본적으로 SwiftUI는 view의 사이즈와 위치가 safe area를 넘지 않도록 조절합니다. 만약 safe area까지 백그라운드를 넓게 그려야 한다면, ignoresSafeArea(_:edges:) modifier를 이용하면 됩니다.var body: some View { ZStack { background VStack { Image(systemName: \"globe\") .imageScale(.large) .foregroundColor(Color.green) Text(\"Hello, world!\") .foregroundColor(Color.white) } } .ignoresSafeArea()}마무리SwiftUI에서 아주 간단하게 background(:alignment:) modifier를 이용해서 view에 background를 추가할 수 있습니다. ZStack을 이용해서 화면 전체에 백그라운드를 추가할 수 있고, safe area까지 넓혀야 한다면 ignoresSafeArea(_:edges:) modifier를 이용하여 그릴 수 있습니다.SwiftUI 관련 글을 더 보고 싶다면 스위프트UI 카테고리 페이지를 확인해 볼 수 있으며, 질문이나 피드백이 있다면 트위터 혹은 이메일로 연락 주세요.글 읽어주셔서 감사합니다.ResourceAdding a Background to Your View" }, { "title": "스위프트 typealias 활용하기", "url": "/posts/typealias-usage/", "categories": "", "tags": "swift", "date": "2021-12-10 00:00:00 +0000", "snippet": "스위프트에 있는 typealias는 기존에 존재하는 타입을 다른 이름으로 정의할 때 사용합니다. 상황에 따라서 기존에 있는 타입을 조금 더 적합한 이름으로 사용할 때 유용합니다. 예를 들어, 가격이 Int 타입인 상품 구조체struct가 있습니다.struct Product { let price: Int}Int 타입으로 사용해도 괜찮으나, 화폐 단...", "content": "스위프트에 있는 typealias는 기존에 존재하는 타입을 다른 이름으로 정의할 때 사용합니다. 상황에 따라서 기존에 있는 타입을 조금 더 적합한 이름으로 사용할 때 유용합니다. 예를 들어, 가격이 Int 타입인 상품 구조체struct가 있습니다.struct Product { let price: Int}Int 타입으로 사용해도 괜찮으나, 화폐 단위로 사용하고 싶다면 typealias를 이용해서 Won이라는 별칭을 만들어 사용할 수 있습니다.typealias Won = Intstruct Product { let price: Won let shippingCost = Won.zero}이와 같이 기존에 존재하는 타입을 별칭을 만들어서 사용할 수 있습니다. 하지만 typealias를 다른 용도로 활용할 수 있는데 몇 가지를 소개하겠습니다.외부 라이브러리 타입 구분외부 라이브러리를 사용하면 라이브러리 내에서 만든 클래스 혹은 타입들이 보통 특이한 이름을 가지거나 구분할 수 있는 접두사가 붙여진 이름을 사용합니다. 하지만 간혹 외부 라이브러리에서 만든거라고 구분하기 힘든 이름들이 있습니다. 예를 들어, Lottie라는 애니메이션 관련 라이브러리에서 애니메이션을 다루는 view인 AnimationView가 있습니다. 만약 프로젝트 안에서 이미 AnimationView라는 커스텀 view를 이미 사용하고 있다면 구분하기 어려울 수 있습니다. 이럴 때, 외부 라이브러리에서 만든 view로 인식할 수 있도록 typealias를 이용해서 LottieAnimationView라고 별칭을 만들어 사용할 수 있습니다.typealias LottieAnimiationView = AnimationViewprivate var confirmAnimationView: LottieAnimationView?Tuple의 이름으로 만들어 사용하기스위프트에 있는 튜플은 다수의 값들을 하나의 구성된 값으로 사용할 수 있게 해줍니다. 튜플을 하나의 이름으로 만들어 사용할 수 있는데, typealias를 이용해서 사용할 수 있습니다.typealias SaleRange = (min: Int, max: Int)let saleRange = SaleRange(min: 0, max: 100)let maxSaleRange = saleRange.max다수의 프로토콜 채택하기다수의 프로토콜을 채택하여 구현해야 하는 경우가 있는데, 이럴 때 typealias를 이용해서 조합해서 만들 수 있습니다. 아마 가장 대표적인 것은 Codable이 있습니다.typealias Codable = Decodable &amp; Encodable이와 비슷하게 다수의 프로토콜을 채택하여 구현해야 하는 경우가 있는데, 바로 tableview 혹은 collectionview와 delegate 패턴을 사용하는 경우가 있습니다. 예를 들어 다양한 cell로 구성된 collectionview가 있는 viewcontroller가 있습니다. 각 cell에서 어떤 동작을 취하면 viewcontroller가 처리하도록 각 cell의 프로토콜을 만들어 delegate을 이용해서 넘길 수 있습니다. 이럴 때, 하나의 Delegate라는 별칭을 만들어서 다수의 프로토콜을 채택하도록 만들 수 있습니다.먼저, collectionview의 DataSource와 Delegate를 담당할 CollectionViewDataSource를 하나 생성하고, cell을 configure할 때, delegate를 설정하도록 합니다.class CollectionViewDataSource: NSObject, UICollectionViewDelegate, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout { typealias Delegates = ProductCellDelegate &amp; ProductHeaderDelegate private weak var delegates: Delegates? init(delegates: Delegates?) { self.delegates = delegates // do additional work if needed } // cellForItemAt에서 cell 만들고 delegate를 할당한다 func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell { let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"Cell\", for: indexPath) as! ProductCell guard let product = products[indexPath.item] else { return cell } cell.configure(product: product, delegate: delegates) return cell } // viewForSupplementaryElementOfKind에서 header 만들고 delegate를 할당한다 func collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, at indexPath: IndexPath) -&gt; UICollectionReusableView { let section = indexPath.section switch kind { case UICollectionView.elementKindSectionHeader: let header = collectionView.dequeueReusableSupplementaryView(ofKind: kind, withReuseIdentifier: \"Header\", for: indexPath) as! ProductHeaderView header.delegate = delegate return header default: assert(false, \"Invalid element type\") } }}그다음에는 viewcontroller에서 CollectionViewDataSource를 가지고 collectionview 구성할 때, viewcontroller가 프로토콜을 채택하여 구현하도록 하고 CollectionViewDataSource의 delegates를 viewcontroller로 할당하면 됩니다.class ViewController: UIViewController { @IBOutlet weak var collectionView: UICollectionView! ... func setupCollectionView() { let dataSource = CollectionViewDataSource(delegates: self) collectionView.dataSource = dataSource collectionView.delegate = dataSource }}extension ViewController: ProductCellDelegate { // Implement ProductCellDelegate}extension ViewController: ProductHeaderDelegate { // Implement ProductHeaderDelegate}Closure typealias 사용하기클로저를 typealias를 이용해서 축약하여 타입 만들어 사용할 수 있습니다. 반복적인 closure가 있을 경우 유용하게 사용할 수 있습니다.typealias CompletionHandler&lt;T&gt; = (Result&lt;T, NetworkError&gt;) -&gt; Voidfunc fetchProducts(id: String, then handler: @escaping CompletionHandler&lt;Product&gt;) { ...}func fetchStores(id: String, then handler: @escaping CompletionHandler&lt;Store&gt;) { ...}마무리스위프트의 typealias를 기존의 타입을 다른 이름으로 사용할 수 있지만, 코드를 조금 더 깔끔하게 하거나 읽기 쉬워지는 효과를 볼 수 있습니다. Typealias를 활용해서 프로젝트의 코드를 조금 더 개선하거나 읽기 쉬운 코드로 바꾸는 작업을 해보면 좋을 것 같습니다.스위프트 관련 글을 더 보고 싶다면 스위프트 카테고리 페이지를 확인해 볼 수 있으며, 질문이나 피드백이 있다면 트위터 혹은 이메일로 연락 주세요.글 읽어주셔서 감사합니다." }, { "title": "How to launch app not immediately but launch after waiting", "url": "/posts/how-to-launch-app-when-launched/", "categories": "Tips, Xcode", "tags": "xcode", "date": "2021-10-16 00:00:00 +0000", "snippet": "We usually launch our app immediately when we build and run from Xcode. But there are sometimes we want to launch our app in a specific moment, for example tapping push notifications or testing uni...", "content": "We usually launch our app immediately when we build and run from Xcode. But there are sometimes we want to launch our app in a specific moment, for example tapping push notifications or testing universal links. We can handle that by selecting “Wait for the executable to be launched” from Target &gt; Edit Sceme &gt; Run &gt; Launch settings." }, { "title": "한글 들어간 url string을 인코딩하는 방법", "url": "/posts/korean-string-url-encoding/", "categories": "", "tags": "swift, strings, url", "date": "2021-10-02 00:00:00 +0000", "snippet": "문자열(이후 string)을 URL로 변환하여 사용하는 경우가 있는데, string 값에 한글 혹은 공백 같은 값이 들어갈 경우 nil 값이 반환된다. 퍼센트 인코딩(percent-encoding)을 해야 올바른 url로 변환할 수 있는데, 스위프트 string에서 addingPercentEncoding(withAllowedCharacters:) 을 ...", "content": "문자열(이후 string)을 URL로 변환하여 사용하는 경우가 있는데, string 값에 한글 혹은 공백 같은 값이 들어갈 경우 nil 값이 반환된다. 퍼센트 인코딩(percent-encoding)을 해야 올바른 url로 변환할 수 있는데, 스위프트 string에서 addingPercentEncoding(withAllowedCharacters:) 을 사용하면 된다. 파라미터로 .urlQueryAllowed을 넣는데, 사용하려는 URL 형식에 맞게 CharacterSet에 있는 값들 중에 사용하면 된다.import Foundationlet urlString = \"https://www.google.com/search?q=애플 스위프트\"if let encodedString = urlString.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) { print(encodedString) // Prints \"https://www.google.com/search?q=%EC%95%A0%ED%94%8C%20%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8\"}if let encodedURL = URL(string: encodedString) { print(encodedURL) // Prints \"https://www.google.com/search?q=%EC%95%A0%ED%94%8C%20%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8\"} 🚧 주의 여기서 주의할 점은 이미 퍼센트 인코딩되어 있는 string에 사용하면 안 된다. 사용하게 된다면 퍼센트 인코딩되어 있는 string에 있는 퍼센트 문자가 또 퍼센트 인코딩하는 것을 발생할 수 있다.참고Apple Developer Documentation" }, { "title": "스위프트에서 빌더 패턴 구현해보기", "url": "/posts/create-builder-pattern-in-swift/", "categories": "", "tags": "architecture, design pattern", "date": "2021-09-23 00:00:00 +0000", "snippet": "최근에 회사에서 커스텀 해서 사용하는 뷰를 사용해야 하는 경우가 생겼는데, 정해진 규칙이 있고 다양하게 조립하여 뷰를 그릴 수 있다고 판단하여 builder pattern(이하 빌더 패턴)으로 만들어 구현해 보았다. 회사 직원들도 잘 만들었다고 했고, 직접 사용하면서 불편한 점이 없다고 해서 다행이라고 생각했다. 다른 부분에도 적용하여 만들어보고 싶어...", "content": "최근에 회사에서 커스텀 해서 사용하는 뷰를 사용해야 하는 경우가 생겼는데, 정해진 규칙이 있고 다양하게 조립하여 뷰를 그릴 수 있다고 판단하여 builder pattern(이하 빌더 패턴)으로 만들어 구현해 보았다. 회사 직원들도 잘 만들었다고 했고, 직접 사용하면서 불편한 점이 없다고 해서 다행이라고 생각했다. 다른 부분에도 적용하여 만들어보고 싶어, 혼자 공부했던 것을 정리할 겸 글을 쓰게 되었다. 빌더 패턴이 무엇인지, 어떻게 만들어 사용하면 좋을지 소개하겠다.객체를 생성하다빌더 패턴이란 객체를 생성할 때 사용하는 패턴으로, 자바에서 많이 사용한다. 복잡하게 많은 파라미터를 넣어 객체를 생성하지 않고, 차례대로 값을 넣으면서 객체를 생성하는 식의 구조다. 예를 들면, 아래와 같이 카드 형태의 뷰를 만든다고 해보자. 카드 형태의 뷰를 그리기 위해 타이틀과 모서리 반경, 색깔을 설정한다.let cardView = CardView()cardView.titleLabel.text = \"New app update\"cardView.contentView.cornerRadius = 8cardView.contentView.backgroundColor = .systemBlue카드 뷰를 직접 생성해서, 그리는데 필요한 부분들에 직접 값을 할당해서 사용하고 있다. 만약 뷰의 서브 뷰를 직접 접근하지 않고 싶다면, configure 함수를 만들어서 사용할 수 있다. 이제 여기서 서브타이틀이 필요하고 이미지가 필요하다면, 각 서브 뷰들을 추가하고 configure 함수에 파라미터를 추가해서 설정해야 한다. 점점 서브 뷰들이 많아지면, configure 함수의 파라미터도 많아진다. 기본값이 있다면, swift의 default value를 이용해서 불필요한 설정을 줄일 수 있다. 하지만 파라미터가 많아지는, 즉 설정하는 부분이 점점 복잡해지고 더러워지는 문제를 피할 수 없다. 빌더 패턴이 이 문제를 해결할 수 있다.let cardView = CardViewBuilder()\t.withTitle(\"New app update\")\t.withCornerRadius(8)\t.withBackgroundColor(.systemBlue)\t.build()빌더 패턴을 사용하면 복잡한 생성자를 줄일 수 있고, 위와 같이 프로퍼티에 접근해서 사용하는 부분을 private으로 하여 외부에서 접근 못 하게 할 수 있다. 빌더 패턴으로 자기 자신을 return 하여 configure 하는데, 이 부분은 chaining 하는 것 처럼 사용하여, 지금의 SwiftUI와 매우 비슷한 것을 볼 수 있다.Text(\"This is title\") .foregroundColor(.red) .font(.system(size: 14, weight: .bold, design: .default))빌더 패턴 구조빌더 패턴에 대해서 더 자세히 보면, 구조는 Director, Builder, Product으로 구성되어 있다. Product - 생성하고 싶은 객체 Builder - 생성하고 싶은 Product를 생성해 주고 반환해 주는 구성 요소 Director - Builder를 이용해서 필요한 product를 받아서 처리하는 구성 요소. 사용하는 용도에 따라 Director를 이용할 수 있고, 직접 Builder를 접근해서 product 반환할 수 있다.구현하기간단하게 Builder를 하나 만들어서 구현할 수 있다. 커스텀 해서 사용하는 뷰를 그리는 빌더를 만들 수 있고, 상품 혹은 자동차와 같이 객체를 만드는 빌더를 만들 수 있다. Director를 사용하여 빌드 패턴을 만들어보기로 하고, 피자를 만드는 빌드 패턴을 구현할 것이다. 빌더 패턴에 맞게 구현한 것이기 때문에 클래스가 많고 불필요한 코드가 보일 수 있습니다. 사용하려는 프로젝트에 맞춰서 구현해서 만들어 사용하는 것을 권장합니다.Product피자는 도우와 토핑, 사이즈를 구성하는 클래스를 만든다. class Pizza { private var dough: Dough = .basic private var toppings = [Topping]() private var size: Size = .regular func setDough(_ dough: Dough) { self.dough = dough } func setToppings(_ toppings: [Topping]) { self.toppings = toppings } func setSize(_ size: Size) { self.size = size } func listPizzaInfo() -&gt; String { let toppingList = toppings.map { $0.rawValue } return \"Your pizza's size is \\(size.rawValue) and the dough is \\(dough.rawValue), toppings are \\(toppingList.joined(separator: \", \")).\" }}Builder피자들은 공통적으로 사이즈에 맞게, 도우를 선택하고, 토핑을 뿌린 다음에 만들어진다. 프로토콜을 만들고, 빌더가 채택해서 구현하도록 만든다.protocol Builder { func reset() func setDough(_ dough: Dough) func addToppings(_ toppings: [Topping]) func setSize(_ size: Size)}class PizzaBuilder: Builder { private var pizza = Pizza() func reset() { self.pizza = Pizza() } func setDough(_ dough: Dough) { self.pizza.setDough(dough) } func addToppings(_ toppings: [Topping]) { self.pizza.setToppings(toppings) } func setSize(_ size: Size) { self.pizza.setSize(size) } func getPizza() -&gt; Pizza { let result = self.pizza reset() return result }}피자를 구성하는 요소들을 설정하는 부분들이 주로 있으며, 여기서 getPizza 함수를 이용해서 만든 pizza 프로덕트를 반환한다. reset 함수가 있는 이유는 만들어진 프로덕트를 반환하고 새로운 프로덕트를 만들기 위해서 초기화하는 작업으로 보면 된다. 한 빌더에 많은 프로덕트를 만들 수 있기 때문에 새로운 프로덕트를 만들기 위한 준비로 보면 된다. 하지만 일회성으로 빌더 만들고 사용한다면, 굳이 reset 함수가 필요 없을 수 있다.Director피자 빌더를 이용해서 피자를 만들고 사용할 director 클래스는 꼭 필요한 요소는 아니다. View Controller 혹은 빌더를 사용하는 부분에서 직접 빌더를 만들어서 사용할 수 있기 때문이다. 여기서는 간단하게 치즈 피자와 페퍼로니 피자를 만드는 Director 클래스를 만들었다.class Director { private var builder: Builder? func buildCheesePizza(_ builder: Builder) { builder.reset() builder.setDough(.cheeseCrust) builder.addToppings([.extraCheese, .mushrooms, .sausage, .greenPeppers, .blackOlives]) builder.setSize(.regular) } func buildPepperoniPizza(_ builder: Builder) { builder.reset() builder.setDough(.basic) builder.addToppings([.pepperoni, .mushrooms, .sausage, .greenPeppers, .blackOlives]) builder.setSize(.regular) }}Client실제로 프로덕트인 피자가 필요한 클라이언트 부분이 있다. Director를 통해서 피자를 얻어서 사용한다. Director와 마찬가지로 꼭 필요한 구성 요소는 아니다. 직접 빌더를 만들어서 사용할 수 있기 때문이다.class Client { func makeCheesePizza() { let director = Director() let pizzaBuilder = PizzaBuilder() director.buildCheesePizza(pizzaBuilder) let cheesePizza = pizzaBuilder.getPizza() print(cheesePizza.listPizzaInfo()) } func makePepperoniPizza() { let director = Director() let pizzaBuilder = PizzaBuilder() director.buildPepperoniPizza(pizzaBuilder) let pepperoniPizza = pizzaBuilder.getPizza() print(pepperoniPizza.listPizzaInfo()) }}let client = Client()client.makeCheesePizza()print()client.makePepperoniPizza()// Prints// \"Your pizza's size is regular and the dough is cheeseCrust, toppings are extraCheese, mushrooms, sausage, greenPeppers, blackOlives.\"// \"Your pizza's size is large and the dough is basic, toppings are pepperoni, mushrooms, onions, blackOlives.\"코드가 생각보다 굉장히 길고 클래스가 많아진 것을 볼 수 있다. 하지만 실제로 client에서 호출해서 사용하는 부분을 보면 단순하다고 볼 수 있다. 구현하는 부분은 빌더가 하고, 클라이언트는 빌더가 만든 피자를 받아서 사용하면 된다. 완성된 전체적인 코드는 gist에서 확인할 수 있다.작업하는 프로젝트 성격에 맞춰서 조금 더 가볍게 구현할 수 있다. 위에서 예를 든 카드 뷰처럼 직접 빌더를 만들고 설정하는 부분을 클라이언트 단(view controlller일 수 있고, 다른 부분일 수 있는)에서 직접 호출해서 써도 된다. 맨 처음 만든 예시처럼 pizza builder를 만든다면, 아래와 같을 수 있다.let pizza = PizzaBuilder()\t.withSize(.regular)\t.withToppings([.extraCheese, .mushrooms, .sausage, .greenPeppers, .blackOlives])\t.withDough(.cheeseCrust)\t.build()print(pizza.listPizzaInfo())// Prints \"Your pizza's size is regular and the dough is cheeseCrust, toppings are extraCheese, mushrooms, sausage, greenPeppers, blackOlives.\"UIStackView와 사용하기빌더 패턴과 잘 어울려 사용할 수 있는 컴포넌트는 개인적으로 UIStackView라고 생각한다. 차례대로 필요한 부분들을 만드는데, 서브 뷰들을 하나씩 만들어 addArrangedSubview(_:)를 이용해서 추가할 수 있다. 또한, 순서대로 만들고 싶다면, 빌더 패턴의 빌드하는 부분의 순서를 변경해서 UIStackView에 순서대로 추가할 수 있다.커스텀 뷰가 프로덕트에 해당하기 때문에, 해당 프로덕트에 stack view를 만들어서 서브 뷰들을 생성해서 stack view에 추가하는 식으로 구현할 수 있다.class CustomView: UIView { private let containerView = CustomContainerView() private func configureContainerView() { // configure basic settings } func addTitle(_ title: String, spacing: CGFloat = 10) { let label = UILabel() ... containerView.stackView.addArrangedSubview(label) } func withSubTitle(_ subTitle: String) { let label = UILabel() ... containerView.stackView.addArrangedSubview(label) } func addImage(_ image: UIImage, size: CGSize) { let imageView = UIImageView(image: image) ... containerView.stackView.addArrangedSubview(imageView) } func addButtons(_ buttons: [CustomButton]) { containerView.addButtonStackView() buttons.forEach { containerView.buttonStackView.addArrangedSubview($0) } }}let customView1 = CustomViewBuilder()\t.withTitle(\"Notice\")\t.withSubTitle(\"Are you sure to delete this list?\")\t.withButtons([.cancelButton, .okButton])\t.build()let customView2 = CustomViewBuilder()\t.withImage(defaultImage)\t.withButtons([.cancelButton, .okButton])\t.withTitle(\"Notice\")\t.withSubTitle(\"Are you sure to delete this list?\")\t.build()순서가 영향이 끼칠 수 있는 뷰를 그릴 때, 빌더 패턴을 이용하고 UIStackView를 이용한다면 쉽게 구현해서 사용하는 것을 볼 수 있다.주의점빌더 패턴은 수많은 구성 요소를 설정해야 하는 객체를 생성할 때 사용하면 좋다. 불필요하게 코드가 늘어날 수 있기 때문에, 실제로 객체를 만들 때 구성 요소가 많은지, 생성자 하나로도 충분한지 고려해서 빌더 패턴을 사용할지 결정해야 한다. 아니면, 위에서 예시로 든 stack view를 이용해서 화면을 그리는 부분이 필요하다면 사용할 수 있다. 물론 프로젝트의 크기에 따라 적용할지는 고려해야 한다.결론빌더 패턴은 복잡한 객체를 생성할 때 차례대로 만들어 사용할 수 있을 때 효과적이다. 스위프트에서는 빌더 패턴이 흔하지 않는 패턴이지만, 필요하다면 충분히 빌더 패턴을 만들어서 적용할 수 있는 것을 볼 수 있다. 작업하는 프로젝트에 빌더 패턴으로 만들어 사용할 수 있는 부분이 있다면 적용해 보는 것을 추천드립니다.gist: PizzaBuilder.swift참고: Builder" }, { "title": "Use Live View in Swift Playground", "url": "/posts/use-live-view-in-swift-playground/", "categories": "", "tags": "swift playground, developer tools", "date": "2021-09-21 00:00:00 +0000", "snippet": "Recently I’ve been using Swift Playground app on iPad for studying Swift language. Personally, I think the playground app is one of the best apps for learning swift. While writing swift code is eno...", "content": "Recently I’ve been using Swift Playground app on iPad for studying Swift language. Personally, I think the playground app is one of the best apps for learning swift. While writing swift code is enough, there are sometimes to write UI related code. Here is how to use swift playground live view to show view.Add the below code to the swift playground. Importing PlaygroundSupport gives us to use live playground previewing.import PlaygroundSupportimport UIKitclass ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() // Write something }}After writing some view-related code, we need to add a code to create and present the view controller. Adding the view controller to the playground live view will do the work.let controller = ViewController()PlaygroundPage.current.liveView = controllerIf you build and run that playground, the view will appear on the assistant editor. Below is the screenshot of swift playground on iPad. We can also use navigation controller to push and pop a detail view.Try using this code to write a simple UI related code or more, especially on iPad. It is one of a best tool for learning swift. Try it out!" }, { "title": "Xcode 시뮬레이터 동영상 녹화하는 방법", "url": "/posts/how-to-record-screen-xcode-simulator/", "categories": "Tips, Xcode", "tags": "xcode", "date": "2021-09-02 00:00:00 +0000", "snippet": "시뮬레이터로 앱 테스트하다 보면 스크린샷을 찍어서 사진으로 사용할 수 있다. 하지만 동영상으로 녹화해서 공유하고 싶은 상황이 발생할 수 있는데, 예전에는 Quick Player 앱을 사용하는 등 다른 방법으로 녹화해서 하는 방법이 있다. 하지만 Xcode 시뮬레이터에서 직접 동영상을 녹화하는 방법이 있다. Xcode 12.5 이상부터 가능한 것으로 ...", "content": "시뮬레이터로 앱 테스트하다 보면 스크린샷을 찍어서 사진으로 사용할 수 있다. 하지만 동영상으로 녹화해서 공유하고 싶은 상황이 발생할 수 있는데, 예전에는 Quick Player 앱을 사용하는 등 다른 방법으로 녹화해서 하는 방법이 있다. 하지만 Xcode 시뮬레이터에서 직접 동영상을 녹화하는 방법이 있다. Xcode 12.5 이상부터 가능한 것으로 보입니다.1. 동영상 녹화하기Simulator 앱에서 File &gt; Record Screen(⌘ + R)을 누르면 바로 시뮬레이터 동영상 녹화가 시작한다.시뮬레이터에서 녹화가 시작하면 아래와 같이 빨간 녹화 버튼이 나타난다. 녹화를 끝내고 싶다면 해당 빨간 녹화 버튼을 누르면 된다.2. 녹화한 동영상 저장하기녹화를 끝내면 시뮬레이터 옆에 아주 작게 녹화한 동영상이 재생된다. 기본적으로 데스크탑 폴더에 mp4 형식으로 저장된다. 여기서 오른쪽 버튼을 누르면 어디에 저장할지, gif 형식으로 저장할지 선택할 수 있다.환경 설정Simulator menu &gt; Preferences 메뉴를 선택하면 시뮬레이터에 대한 설정을 할 수 있다. 예를 들어서 Single Touch 하는 것을 보여주거나 GIF 사이즈를 조절할 수 있다.결론며칠 전에 시뮬레이터 동영상을 녹화하는 방법을 최근에서야 알게 된 사람들을 보면서, 관련하여 글을 작성해보면 좋겠다고 생각해 글을 작성해 보았다. 앞으로도 종종 잘 모르는 팁들이 있으면 블로그 글을 작성하여 공유할 예정이다." }, { "title": "Xcode 저장공간 이해 및 관리", "url": "/posts/manage-xcode-related-data/", "categories": "", "tags": "xcode", "date": "2021-08-09 00:00:00 +0000", "snippet": " 해당 글은 Understanding and Managing Xcode Space 글을 보고 정리한 글입니다.간혹 Xcode 빌드할 때 문제가 생기는데, 많이 사용해본 해결 방법은 바로 Derived Data 폴더를 지우는 것이다. Derived Data 폴더가 생각보다 저장공간을 많이 차지하는데, 삭제하면 어느 정도 저장공간이 확보된다. 그리고 새...", "content": " 해당 글은 Understanding and Managing Xcode Space 글을 보고 정리한 글입니다.간혹 Xcode 빌드할 때 문제가 생기는데, 많이 사용해본 해결 방법은 바로 Derived Data 폴더를 지우는 것이다. Derived Data 폴더가 생각보다 저장공간을 많이 차지하는데, 삭제하면 어느 정도 저장공간이 확보된다. 그리고 새로운 아이폰을 발표할 때마다 사용하지 못하는 시뮬레이터를 지우는 일을 매년 하고 있다. 이 부분도 mac 저장공간에 저장되고 있기 때문에 관련 파일들을 지우면 저장공간을 확보할 수 있다. 관련하여 검색하다가 Raywenderlich에서 잘 정리한 글이 있어, 해당 글을 보고 정리를 해봤다.Xcode Derived Data프로젝트를 빌드할 때, Xcode가 해당 프로젝트의 빌드 파일들을 derived data 폴더에 저장한다. 위치는 아래 경로에 있다.~/Library/Developer/Xcode/DerivedDataModuleCache.noindex 폴더는 Xcode가 컴파일한 모듈(modules)을 저장한다. Xcode는 캐시된 모듈을 프로젝트들과 공유하며 빠르게 빌드할 수 있게 한다. 프로젝트 빌드 폴더도 동일하게 빠르게 빌드할 수 있게 해준다. 해당 프로젝트 폴더를 지우면 mac 저장 공간도 줄이고 이상한 버그도 해결할 수 있지만, 다음 빌드할 때 시간이 더 소요된다.Clearing Archives프로젝트들을 archive하면 mac 어딘가에 저장이 된다. 몇 년간 archive하고 지우지 않는다면, 저장 공간을 꽤 많이 차지할 수 있다. 아카이브하면 아래 경로에 날짜별로 아카이브한 폴더가 생긴다. 날짜별 폴더에 들어가면 아카이브한 파일이 있다.~/Library/Developer/Xcode/Archives날짜별 폴더에 들어가 보면 아래와 같이 아카이브 파일이 있는데, 해당 파일을 삭제하면 된다. 프로젝트 빌드에 영향을 끼치지 않고 저장 공간을 줄일 수 있지만, 혹시 다시 테스트플라이트 올려야 하는 경우를 위해서 지우지 않아도 괜찮다. 또한, 현재 서비스하고 있는 앱을 디버깅하는 데 필요한 파일인 dSYM 파일이 있는데, 아카이브 패키지 안에 있다. 되도록 더 사용하지 않을 것으로 판단할 때 지우는 것을 추천한다.Clearing Simulators시뮬레이터에 빌드하게 되면 앱을 설치하고 실행해서 테스트할 수 있다. 사진을 저장하는 게 있다면, 시뮬레이터의 사진 앨범에 저장하게 된다. 하지만 설치한 앱을 삭제해도, 사진 앨범에 저장한 사진 등 기타 자료에 대해서는 남아 있을 수 있다. 완전하게 깨끗한 시뮬레이터로 테스트하고 싶다면 시뮬레이터의 콘텐츠를 지우는 방법이 있다.시뮬레이터 킨 상태에서 Device &gt; Erase All Content and Settings 메뉴를 선택하면 아래와 같이 시뮬레이터에 팝업이 나타난다. 지우고 싶다면 Erase를 누르면 된다. 이렇게 되면 저장했던 사진들이 지워지고 기타 Core Database 등을 지우게 된다.Deleting Unavailable Simulators매년 새로운 아이폰 혹은 아이패드 기기를 출시하면 새로운 버전의 Xcode에서 해당 기기들이 포함해서 출시된다. 이렇게 하다 보면 오래돼서 안 쓰게 되는 혹은 못 쓰게 되는 시뮬레이터들이 생긴다. 이런 시뮬레이터들도 저장 공간을 차지한다.아래 터미널에 명령어를 치면 사용하지 못하는 시뮬레이터들을 지울 수 있다.xcrun simctl delete unavailable만약 사용하지 못하는 시뮬레이터들이 있었다면, 명령어를 친 후에 output으로 어떤 시뮬레이터들이 지웠는지 안내해준다. 만약 output이 없다면 사용하지 못하는 시뮬레이터들이 없다는 뜻이다.Device Support기기를 맥이랑 연결해서 설치하거나 디버깅한다면, Xcode는 device support 파일들을 만든다. Xcode는 이렇게 생성된 파일들을 크래시 로그 보는 것과 같이 개발 관련 기능들을 지원할 때 사용한다. OS 버전 별로 만들며 마이너 버전까지 지원한다. 예를 들면 iOS 14.1, 14.2, 14.2.1 등.Xcode는 해당 파일들을 제거하지 않아 시간 지날수록 계속 쌓일 수 있다. 기기를 연결할 때마다 Xcode가 파일들을 자동으로 생성하기 때문에 해당 파일들을 제거해도 괜찮다.아래 경로에 iOS device support 파일들이 있다.~/Library/Developer/Xcode/iOS DeviceSupport생각보다 저장 공간을 많이 차지하기 때문에 지원하는 iOS 버전을 몇 개 빼고 지우는 것을 추천한다. 해당 폴더는 iOS device만 있기 때문에 watchOS와 tvOS 따로 있으며, 해당 폴더도 정리해도 괜찮다.~/Library/Developer/Xcode/watchOS DeviceSupport~/Library/Developer/Xcode/tvOS DeviceSupportCaches캐시는 캐시를 사용하는 프로그램을 빠르게 실행할 수 있도록 데이터를 저장한다. 캐시가 저장하는 데이터는 일시적으로 사용하는 데이터이다. 캐시는 프로그램이 실행할 때마다 생성되기 때문에, 지워도 괜찮다. 다만 대용량 캐시일 경우, 캐시가 재빌드하면서 시간이 좀 소요되는 것을 경험할 수 있다.캐시 삭제는 공간을 재확보하기 위한 일반적인 전략이다. 예를 들면, Xcode 캐시를 삭제하면 오래되고, 사용하지 않는 데이터를 삭제한 채 남게 된다. 나중에 Xcode는 필요할 때 재생성해서 사용하게 된다.가끔 Xcode 사용하면서 문제가 생긴다면 캐시를 지우는 것도 해결 방법의 하나다. 캐시는 보통 ~/Library/Caches 폴더에 저장된다. Xcode 캐시도 동일하게 저장되는데, ~/Library/Caches/com.apple.dt.Xcode 경로에 있다.외부 라이브러리를 사용한다면 Carthage 혹은 CocoaPods를 사용하게 되는데, 이와 관련한 캐시들도 저장이 된다. Carthage 캐시의 경로는 ~/Library/Caches/org.carthage.CarthageKit 이다. CocoaPods는 다르게 특별한 명령어를 이용해서 캐시를 삭제할 수 있다. 아래 명령어를 터미널에 치면 CocoaPods 캐시를 삭제한다.pod cache clean --allConclusion위의 내용을 정리하면서 Xcode 사용하면서 다양하게 빌드 및 프로젝트 관련된 파일들이 저장되는 것을 알게 되었고, 관련 파일들은 어디에 저장되는지 그리고 삭제 가능한지도 알아볼 수 있었다. 덕분에 mac 저장공간을 효율적으로 관리할 수 있는 팁을 알게 되었다." }, { "title": "개발하면서 겪은 경험들은 언젠가 도움이 될 것이다", "url": "/posts/experience-will-help-you/", "categories": "Blog", "tags": "blog", "date": "2021-08-02 00:00:00 +0000", "snippet": "며칠 전에 “Software Engineering Isn’t Magic“이라는 글을 읽으면서 많이 공감되었다. 최근에 비슷한 경험도 있어서 개발에 대한 나의 하나의 시각에 대해서 글을 쓰게 되었다. 나도 아직 연차가 많지 않다고 느끼지만, 조금이라도 내 경험을 통해서 신입 개발자들에게 응원이 되었으면 좋겠다.몇 달 전에 API가 중복으로 호출하는 때가...", "content": "며칠 전에 “Software Engineering Isn’t Magic“이라는 글을 읽으면서 많이 공감되었다. 최근에 비슷한 경험도 있어서 개발에 대한 나의 하나의 시각에 대해서 글을 쓰게 되었다. 나도 아직 연차가 많지 않다고 느끼지만, 조금이라도 내 경험을 통해서 신입 개발자들에게 응원이 되었으면 좋겠다.몇 달 전에 API가 중복으로 호출하는 때가 있어 확인해달라는 이슈가 있었는데, 당시에 QA 기간이라 신경을 못 쓸 것 같아 신입 개발자에게 확인해보라고 했다. 시간이 좀 지나면서 갑자기 생각난 원인이 될 만한 내용을 신입 개발자에게 얘기했고, 확인해보겠다고 했다. 다행히 내가 생각했던 문제로 인해 API가 중복으로 호출하고 있는 것을 확인했고, 방지하는 코드를 넣어 확인해보니 정상적으로 잘 동작했다. 신입 개발자와 함께 이슈 수정하면서 그 개발자는 어떻게 그렇게 빨리 찾았냐고 나한테 물어봤다. 나 자신도 빠르게 이슈 원인을 찾은 것도 신기했는데, 비슷한 경험이 있었기 때문에 이와 비슷하지 않을까 얘기한 거라고 대답했다.내가 입사한 해에 시니어 개발자께서 휴가 간 날에 이슈가 터진 일이 있었다. 앱이 상품 상세 페이지에 진입하면 죽는 이슈였다. 혼자서 이슈를 잘 대응할 수 있을지 걱정하며 원인을 찾아 나섰다. 다행히 원인이 올바르지 않은 데이터 타입으로 내려오고 그것을 casting 하는 부분에서 크래시가 발생한 것을 찾았다. 관련하여 보고했고 무사히 이슈도 해결이 되었다. 이 일 계기로 잘못된 데이터 타입 내려올 경우 크래시가 발생할 수 있다는 것을 깨닫고 if let 혹은 guard let을 해서 안전하게 값을 꺼내는 방법으로 코드를 바꿨다. 그리고 몇 해 지나고 올해, 주니어 개발자가 나에게 잘 동작하는 부분에서 이슈가 나와서 원인 분석해보고 해당 데이터 항목을 사용하고 있는지 물어본 적이 있었다. 혹시 나는 데이터 타입이 다르게 내려와서 그런 거 아닌지 확인해보라고 했다. 잘 되던 동작이 안 된다면 원하는 값으로 안 내려올 가능성이 있기 때문이다. 다행히 내 추론은 맞았고, 백엔드에 원래 사용하던 데이터 타입으로 수정 요청을 했다.혼자 몇 시간을 고민하고 삽질했던 시간이 있었기 때문에, 이와 비슷한 문제에 닥친 다른 개발자에게 빠르게 해답을 줄 수 있었다. 어떻게 하면 그렇게 빠르게 알 수 있냐고 물어보면, 오랫동안 고민하는 시간을 나도 똑같이 해서 해결했기 때문이라고 대답한다.일이 바쁘지 않는다면 주니어 개발자와 협업할 때 나는 최대한 주니어 개발자가 혼자 문제를 해결할 수 있도록 질문하고 방향만 제시하려고 노력한다. 낚시해서 물고기를 주지 않고 나무 막대기를 주고 낚싯대를 만들어서 물고기를 낚을 수 있도록 해준다. 고군분투하면서 빨리 해결하지 못하겠지만, 낚싯대를 만들면서 깨달은 경험을 가지고 나중에 낚싯대가 부서지면 고칠 수 있고, 더 좋은 낚싯대를 만들 수 있는 거름이 될 거라고 생각된다. 천천히 개발하다 보면 나중에 빠르게 개발할 수 있게 될 것이다." }, { "title": "Protocol extensions를 이용해서 기본값 제공하기", "url": "/posts/using-protocol-extension-for-default-parameter/", "categories": "", "tags": "swift, protocol", "date": "2021-07-29 00:00:00 +0000", "snippet": "프로토콜에 정의한 메서드는 기본값을 가질 수 없다. 하지만 extension을 이용해서 프로토콜에 정의한 메서드 혹은 프로퍼티에 기본값을 제공할 수 있다.protocol Moveable { func move(to point: CGPoint)}위와 같이 Moveable 프로토콜에 메서드 하나를 정의했는데, 여기서 기본값을 지정한다면 Xcode에서 ...", "content": "프로토콜에 정의한 메서드는 기본값을 가질 수 없다. 하지만 extension을 이용해서 프로토콜에 정의한 메서드 혹은 프로퍼티에 기본값을 제공할 수 있다.protocol Moveable { func move(to point: CGPoint)}위와 같이 Moveable 프로토콜에 메서드 하나를 정의했는데, 여기서 기본값을 지정한다면 Xcode에서 에러를 발생한다.protocol Moveable { func move(to point: CGPoint = .zero) // Error: Default argument not permitted in a protocol method}여기서 extension을 이용해서 메서드에 기본값 제공하는 게 가능해진다.extension Moveable { func move(to point: CGPoint = .zero) { move(to: point) }}struct Character: Moveable { let name: String init(name: String) { self.name = name } func move(to point: CGPoint) { print(\"Moving to \\(point)\") }}let mario = Character(name: \"Mario\")mario.move(to: CGPoint(x: 3, y: 0))let luigi = Character(name: \"Luigi\")luigi.move()여기서 주의점은 extension으로 프로토콜에 정의한 메서드를 구현했기 때문에, 프로토콜에서 채택하여 사용하는 부분에서 해당 메서드를 호출하면 extension에 있는 메서드를 부른다. 이렇게 되면 컴파일할 때는 문제가 되지 않으나, 앱을 실행할 때 재귀로 계속 자기 자신을 불러오는 EXC_BAD_ACCESS 에러가 발생한다. 프로토콜을 채택하는 부분에서 꼭 구현을 하거나 조금 더 안전한 방법으로는 기본값으로 설정하고 싶은 파라미터를 뺀 메서드를 만들어서 사용하면 된다.extension Moveable { func move() { return move(to: .zero) }}프로퍼티에도 동일하게 기본값을 제공할 수 있다.protocol Talkable { var greeting: String { get }}extension Talkable { var greeting: String { \"Hello\" }}struct Character: Moveable, Talkable { let name: String init(name: String) { self.name = name } func move(to point: CGPoint) { print(\"Moving to \\(point)\") }}let mario = Character(name: \"Mario\")print(mario.greetings)// Prints \"Hello\"" }, { "title": "WWDC21 Keynote에 대한 나의 생각들", "url": "/posts/my-thoughts-about-wwdc21-keynote/", "categories": "WWDC", "tags": "wwdc", "date": "2021-06-11 00:00:00 +0000", "snippet": "Overview1년 중 가장 즐거운 시간이 돌아왔다. 바로 애플이 개최하는 개발자 컨퍼런스인 WWDC21이다. 작년과 똑같이 온라인으로 진행해서 아쉽지만, 올해는 디지털 라운지, 코드 챌린지 등 다양한 활동을 진행한다. 이번 글은 아주 짧게 올해 발표한 내용에 대해서 내 생각들을 얘기하려고 한다.iOS 15 (소통, 공유)작년보다 굉장히 새로운 것들이...", "content": "Overview1년 중 가장 즐거운 시간이 돌아왔다. 바로 애플이 개최하는 개발자 컨퍼런스인 WWDC21이다. 작년과 똑같이 온라인으로 진행해서 아쉽지만, 올해는 디지털 라운지, 코드 챌린지 등 다양한 활동을 진행한다. 이번 글은 아주 짧게 올해 발표한 내용에 대해서 내 생각들을 얘기하려고 한다.iOS 15 (소통, 공유)작년보다 굉장히 새로운 것들이 많지 않지만, 애플이 중점을 둔 부분을 볼 수 있었다. SharePlay, FaceTime links, Portrait mode in FaceTime 등 사람들과 소통하고 공유하는 부분 위주로 기능들이 많이 나왔다. 현재 사람 만나기가 힘든 시기인 만큼, 이런 기능들을 제공하면서 사람들과의 소통과 공유에 더 편리성을 준 것 같다. 다른 앱에서 비슷한 기능들을 제공하긴 하지만, 애플에서 제공하는 플랫폼 공통으로 사용할 수 있게 점이 다른 것 같다. 써봐야 알 수 있을 것 같다.그리고 개인적으로 Focus 기능도 좋았는데, 업무 시간에 회사와 관련된 업무 알림을 확인하고 기타 알림에 대해서 잘 확인을 못 한다. 그런데도 항상 꼭 보아야 하지 않는 알림들이 아이폰 화면을 깨웠는데, 해당 기능을 사용하면 조금 더 업무에 집중할 수 있을 것 같다. 지속해서 사용하면서 내 패턴에 맞게끔 설정은 필요할 것 같다.iPadOS (멀티태스킹, 퀵노트)애플이 아이패드를 점점 노트북 대신 사용할 수 있는 기기로 많이 발전시키려는 것을 느끼고 있는데, 이번 iPadOS 15의 새로운 기능 중 중 멀티태스킹과 퀵노트가 그 부분인 것 같다. 멀티태스킹 메뉴 통해서 쉽게 앱들을 배치할 수 있고, Shelf라는 것을 이용해서 많은 앱을 원하는 화면에 바로 사용할 수 있도록 배치할 수 있다. 예를 들면, 다양한 웹 사이트를 열어 놓은 사파리 앱들을 잠시 저장해 놓고, 언제든지 볼 수 있도록 Shelf 영역에 배치할 수 있다.또한 오른쪽 하단에서 애플 펜슬로 쓱 쓸어 올리면 빠르게 메모를 작성할 수 있는 Quick Note 기능이 있다. 언제든지 빠르게 메모를 작성할 수 있고, 예를 들면 사파리 앱에서 보고 있다면 해당 사파리 웹 사이트 링크가 메모에 추가할 수 있는 기능도 있다. 아이패드와 애플 펜슬과의 조합을 극대화할 수 있을 것 같다.macOS (Universal Control, Shortcuts)macOS에서 새로 소개한 기능들도 멋졌지만, Universal Control 기능이 정말 놀랍고 멋졌다. 마치 마법처럼 맥을 사용하고 있는 화면에서 옆에 아이패드를 두면, 아이패드 화면으로 마우스 커서가 갈 수 있고, 또한 아이패드에 있는 파일을 끌어서 맥에 다시 붙이면서 사용할 수 있다. 연결선 없이, 동일한 운영체제가 아니어도 왔다 갔다 할 수 있는 것 자체가 정말 신기했다. macOS Monterey 베타로 올리면 가장 먼저 써보고 싶은 기능이다.Shortcuts 앱을 아이폰에서 유용하게 쓰고 있는데, 이 앱도 맥에서도 쓸 수 있게 되었다. 맥 사용하면서 자주 쓰는 것들을 Shortcuts 앱 통해서 만들면 꽤 유용할 것 같다. 어느 개발자는 “Derived Data” 지우는 Shortcut 만들 거라고 했는데 너무 웃겼다.Xcode Cloud, Swift Playground, Swift Concurrency애플이 코드를 클라우드에서 빌드하고 테스트 가능한 프로그램인 Xcode Cloud를 소개했다. 애플에서 제공하는 테스트 및 빌드, 배포 등의 파이프라인을 제공하는 점에서 의미가 매우 크고, 이제 Fastlane이나 다른 자동화 빌드/배포 프로그램을 사용하지 않을 수 있게 된다. 이것도 빠르게 써보고 싶은 서비스이다.Swift Playground 4는 이제 아이패드에서 SwiftUI로 앱을 개발하고, 아이패드에서 앱으로 테스트하고, 앱 스토어에 올리는 것까지 가능하게 된다. 앱 개발을 맥 운영체제와 Xcode 프로그램에서 한정된 있는 것을, 범위가 어디까지인지 모르지만 SwiftUI로 아이패드에서 앱을 개발해서 스토어에 올리는 거는 정말 놀라운 것 같다. 애플이 점점 진입 장벽을 낮추게 하면서 사람들에게 점점 앱을 개발할 수 있는 환경 혹은 기회를 주는 것 같다.Swift Concurrency 내용도 매우 뜨거웠는데, 스위프트 문법에 이제 동시성 프로그래밍을 쉽게 작성할 수 있는 async/await 와 anchor를 소개했다. 앱을 개발하다 보면 동시에 다양한 작업을 수행하는 때도 있는데, 코드들이 꽤 긴 경우가 있고 읽기 복잡한 코드들이 생길 수 있다. 하지만 async/await 키워드를 이용해서 짧고 간결하게 동시성 프로그래밍 코드를 작성할 수 있게 된다. 코드 줄 수가 짧아진 것도 좋고, 점점 모던한 스타일로 가는 스위프트 문법의 발전을 볼 수 있었다.Conclusion이번 WWDC21은 개인적으로 작년보다 더 재밌고 놀라운 것들을 발표한 것 같다. 지금 가지고 있는 기기들을 충분히 사용하면서, 최신 서비스들을 사용할 수 있고 앱을 개발할 수 있는 환경을 제공해준 것 같다. 새로운 스위프트 문법을 소개하면서 점점 스위프트가 발전하는 것을 볼 수 있었다. 앞으로 공개하는 세션들을 통해서 새로운 기술들을 접하고 사용하면서 다음 해를 기다리는 시간을 가지면 좋을 것 같다." }, { "title": "How to show scrollbar over header or footer view", "url": "/posts/how-to-show-scrollbar-over-header-or-footer-view/", "categories": "", "tags": "iOS", "date": "2021-05-12 00:00:00 +0000", "snippet": "OverviewAfter revisiting my old codes, I found some useful code that helped a bug. Although this bug is solved over iOS 13, if your project deployment target is iOS 12 or under, this code might be ...", "content": "OverviewAfter revisiting my old codes, I found some useful code that helped a bug. Although this bug is solved over iOS 13, if your project deployment target is iOS 12 or under, this code might be useful. Only from iOS 12 and under produces this bug. From iOS 13 and above, this bug doesn’t occur.Scrollbar goes under the header or footer viewAs the below image shows, the scrollbar is under the header view. It was a strange bug, and does not look good. But adding the below code helped the bug. It looks like the scrollbar layer’s zPosition was lower than the header view layer’s zPosition.func collectionView(_ collectionView: UICollectionView, willDisplaySupplementaryView view: UICollectionReusableView, forElementKind elementKind: String, at indexPath: IndexPath) { view.layer.zPosition = 0}Reference:StackOverflow" }, { "title": "Cannot find 'Something' in scope", "url": "/posts/cannot-find-in-scope/", "categories": "", "tags": "cocoaPods", "date": "2021-04-28 00:00:00 +0000", "snippet": "After updating some third party sdk version, there was a warning that can’t find some library when building the project.The issue was that some library was separated used, but after updating the sd...", "content": "After updating some third party sdk version, there was a warning that can’t find some library when building the project.The issue was that some library was separated used, but after updating the sdk version, that library went into the main sdk library. (AnalyticsEventSelectContent -&gt; FirebaseAnalytics) The library was redundant in the repo.The way to fix this problem is to remove all coocapods and reinstall it.pod deintegratepod install" }, { "title": "Enable swipe back and the bug", "url": "/posts/enable-swipe-back-and-the-bug/", "categories": "", "tags": "iOS", "date": "2021-04-17 00:00:00 +0000", "snippet": "Enable swipe back when navigation bar is hiddenIn iOS, we can swipe back(left to right) to pop the view controller and navigate back. This is only available when the navigation bar is shown. If we ...", "content": "Enable swipe back when navigation bar is hiddenIn iOS, we can swipe back(left to right) to pop the view controller and navigate back. This is only available when the navigation bar is shown. If we want to swipe back even if the navigation bar is hidden, add below code at the root view.override func viewDidLoad() { super.viewDidLoad() ... navigationController?.interactivePopGestureRecognizer?.delegate = nil}The bugBut be careful when using it. There is a bug, which is when we swipe back at the very root view controller. Nothing happens because there is no view controller to pop. But then, nothing happens when tapping anywhere. The view controller does not response at all. If we swipe back again, a strange view appears from the left as we swipe. After this happens, the root view controller now gets response. Below image shows the strange behavior.To prevent this strange behavior, we need to handle the interactivePopGestureRecognizer to be enabled or disabled. This can be in the root view controller or implement UINavigationControllerDelegate to the root view controller. It depends on how your root view controller is structed.// UINavigationControllerDelegate Implementfunc navigationController(_ navigationController: UINavigationController, didShow viewController: UIViewController, animated: Bool) { interactivePopGestureRecognizer?.isEnabled = viewControllers.count &gt; 1}// or the root view controlleroverride func viewDidAppear(_ animated: Bool) { super.viewDidDisappear(animated) navigationController?.interactivePopGestureRecognizer?.isEnabled = navigationController?.viewControllers.count ?? 0 &gt; 1}Adding this will fix the problem. Maybe the swipe back gesture was troubling, even though the navigation controller does not have view controllers to pop. One of our apps was having some trouble about the view freezing, and we had produced this bug somehow. And it was related to this bug. Adding this code had solved the freezing bug.Reference:Apple DocumentationStackOverflow" }, { "title": "How to hide navigation bar when scrolling", "url": "/posts/hide-navigation-bar-when-swipe/", "categories": "", "tags": "iOS", "date": "2021-04-16 00:00:00 +0000", "snippet": "In UINavigationController, there is a property called hidesBarsOnSwipe which hides its bars when scrolling or swipe down.navigationController?.hidesBarsOnSwipe = trueWe also need to set the view’s ...", "content": "In UINavigationController, there is a property called hidesBarsOnSwipe which hides its bars when scrolling or swipe down.navigationController?.hidesBarsOnSwipe = trueWe also need to set the view’s top anchor to superview’s top anchor. For example, there is a collection view inside a view controller. The collection view’s top anchor is related to Superview’s top anchor. If we don’t set it, we can’t show the navigation bar when scrolling or swipe up.Reference:Apple Developer Documentation" }, { "title": "M1 mac에서 cocoapods 설치하기", "url": "/posts/m1-mac-cocoapods-install/", "categories": "", "tags": "cocoaPods", "date": "2021-04-14 00:00:00 +0000", "snippet": "Update: Homebrew를 이용해서 설치하는 방법 추가하고 글 내용을 조금 수정했습니다.M1 맥 미니 구매하고 나서, 놀라운 퍼포먼스와 무소음 환경을 즐기고 있습니다. Xcode에서 빌드하기 위해, 아직 SPM으로 옮기지 못 한 라이브러리 이용하기 위해서 cocoapods를 설치해야 했습니다. 하지만 인텔 기반 맥에서 cocoapods 설치하는 ...", "content": "Update: Homebrew를 이용해서 설치하는 방법 추가하고 글 내용을 조금 수정했습니다.M1 맥 미니 구매하고 나서, 놀라운 퍼포먼스와 무소음 환경을 즐기고 있습니다. Xcode에서 빌드하기 위해, 아직 SPM으로 옮기지 못 한 라이브러리 이용하기 위해서 cocoapods를 설치해야 했습니다. 하지만 인텔 기반 맥에서 cocoapods 설치하는 방법과 달랐는데, 오늘 이 포스트에서 소개하려고 합니다.Rosetta를 이용하고 ffi 설치해서 cocoapods 설치하는 방법1. 터미널 앱을 Rosetta를 사용하여 열기응용 프로그램에서 터미널 앱에서 오른쪽 클릭을 해 정보 보기를 한 후, ‘Rosetta를 사용하여 열기’를 체크합니다.2. 터미널 앱을 열어서 아래 명령어 입력하기sudo gem install ffi3. Cocoapods 설치 혹은 pod installpod install 명령어를 입력해서 설치하거나, cocoapods이 설치되어 있지 않다면 sudo gem install cocoapods 명령어를 입력하면 됩니다.Homebrew를 이용해서 설치하는 방법최근에 homebrew를 이용해서 개발할 때 필요한 패키지들을 설치하는데, homebrew를 이용해서 cocoapods를 설치할 수 있습니다.아래 명령어를 입력하면 설치가 됩니다. (Homebrew cocoapods 사이트)brew install cocoapods애플에서 Swift Packaage Manager를 지원하고 있기 때문에, SPM으로 설치하는 것을 권장합니다. 하지만, 아직 SPM을 지원하지 않는 라이브러리를 사용하고 있다면 cocoapods를 설치해서 사용해야 합니다.위 2가지 방법 중 하나로 cocoapods를 설치하면 사용할 수 있습니다.관련 이슈는 아래 깃헙 주소 참고하여 보시면 되겠습니다.참고CocoaPods compatibility with Apple DTK (Apple Silicon) · Issue #9907 · CocoaPods/CocoaPods · GitHub" }, { "title": "iOS 14부터 UILabel에서 한글 사용할 때 줄바꿈 이쁘게 하기 (lineBreakStrategy)", "url": "/posts/korean-line-break-strategy/", "categories": "", "tags": "iOS", "date": "2021-03-31 00:00:00 +0000", "snippet": "iOS에서 UILabel에 한글을 사용할 때, 줄 바꿈이 이쁘게 되지 않아 문제가 됐었는데, 찾다 보니 iOS 14에서부터 한글 사용할 때 줄 바꿈이 이쁘게 할 수 있는 설정이 있다고 해서 테스트해봤다.iOS 13아래 스크린샷과 같이 한글이 길 경우에는 줄 바꿈이 매끄럽지 않다. 위의 레이블은 attributedText이고 아래 레이블은 일반 텍스트이...", "content": "iOS에서 UILabel에 한글을 사용할 때, 줄 바꿈이 이쁘게 되지 않아 문제가 됐었는데, 찾다 보니 iOS 14에서부터 한글 사용할 때 줄 바꿈이 이쁘게 할 수 있는 설정이 있다고 해서 테스트해봤다.iOS 13아래 스크린샷과 같이 한글이 길 경우에는 줄 바꿈이 매끄럽지 않다. 위의 레이블은 attributedText이고 아래 레이블은 일반 텍스트이다.“표준시”, “로 ~”“있습”, “니다. ~”깔끔하게 줄 바꿈이 되지 않는 것을 보일 수 있다. lineBreakMode 프로퍼티를 이용해서 값을 .byWordWrapping으로 설정해도 한글일 때는 잘 먹히지 않는다.iOS 14 (lineBreakStrategy)lineBreakStrategy라는 프로퍼티가 있는데, 정의는 설명되어 있지 않다. 찾다 보니 기존에는 pushOut 값이 있는데, iOS 14에서부터 hangulWordPriority, standard 값이 추가되었다. 영어 이름으로 hangul이 있다는 게 신기했는데, 해당 값을 적용하면 잘 나온다. NSParagraphStyle를 이용해서 설정하고 사용하면 된다.extension NSParagraphStyle { public struct LineBreakStrategy : OptionSet { public init(rawValue: UInt) @available(iOS 9.0, *) public static var pushOut: NSParagraphStyle.LineBreakStrategy { get } @available(iOS 14.0, *) public static var hangulWordPriority: NSParagraphStyle.LineBreakStrategy { get } @available(iOS 14.0, *) public static var standard: NSParagraphStyle.LineBreakStrategy { get } }}attributedLabel.numberOfLines = 0attributedLabel.backgroundColor = .secondarySystemBackground let font = UIFont.systemFont(ofSize: 17, weight: .semibold)let paragraphStyle = NSMutableParagraphStyle()paragraphStyle.lineSpacing = 6// 한글 줄바꿈 적용if #available(iOS 14.0, *) { paragraphStyle.lineBreakStrategy = .hangulWordPriority} let attributes: [NSAttributedString.Key: Any] = [ .font: font, .foregroundColor: UIColor.systemBlue, .paragraphStyle: paragraphStyle]attributedLabel.attributedText = NSAttributedString(string: text, attributes: attributes)여기서 특이한 것은, iOS 14에서는 특별한 설정 없이 일반 텍스트일 때는 잘 나온다. iOS 14부터는 기본적으로 언어에 따라서 줄 바꿈 하도록 되어 있는 것 같은데 맞는지는 다른 언어를 사용해보지 않아서 잘 모르겠다.그리고 또 한 가지, paragraphStyle을 이용해서 텍스트에 attribute를 추가하면 줄 바꿈이 이상하게 나오는데, paragraphStyle을 사용하지 않으면 줄 바꿈이 잘 된다. 즉, paragraphStyle을 사용 안 하면 한글 줄 바꿈이 잘 나온다.이제 iOS 14에서부터 아주 매끄럽게 한글 줄 바꿈이 잘 나오는 것을 확인할 수 있다. 만약 paragraphStyle을 사용한다면, lineBreakStrategy 값을 설정해서 적용하면 잘 나온다.참고: NSParagraphStyle.LineBreakStrategy" }, { "title": "macOS Big Sur에서 Xcode cache 지우는 방법", "url": "/posts/remove-xcode-cache-in-big-sur/", "categories": "Tips", "tags": "xcode", "date": "2021-03-19 00:00:00 +0000", "snippet": "macOS Big Sur에서 Xcode 캐시 혹은 미사용 iOS 시뮬레이터 버전들을 저장공간 &gt; 관리 &gt; 개발자 영역에서 쉽게 지울 수 있습니다.", "content": "macOS Big Sur에서 Xcode 캐시 혹은 미사용 iOS 시뮬레이터 버전들을 저장공간 &gt; 관리 &gt; 개발자 영역에서 쉽게 지울 수 있습니다." }, { "title": "jekyll 블로그 테마를 바꾼 이유", "url": "/posts/why-i-changed-jekyll-theme/", "categories": "Blog", "tags": "blog", "date": "2021-03-08 00:00:00 +0000", "snippet": "기술 블로그 시작2019년 연말부터 거의 꾸준히 글 쓰려고 노력하고 있다. 기술 블로그 통해서 많은 것을 배워서 나도 비슷하게 그런 글을 쓰거나, 아니면 개인적으로 공부한 것을 기록하는 용도로 기술 블로그를 시작했다. 물론, 개인 포트폴리오 용도도 좀 있다. 성실하다는 것을 잘 나타나는 지표로 사용할 수 있기 때문이다. 매일 1일 1커밋으로 Githu...", "content": "기술 블로그 시작2019년 연말부터 거의 꾸준히 글 쓰려고 노력하고 있다. 기술 블로그 통해서 많은 것을 배워서 나도 비슷하게 그런 글을 쓰거나, 아니면 개인적으로 공부한 것을 기록하는 용도로 기술 블로그를 시작했다. 물론, 개인 포트폴리오 용도도 좀 있다. 성실하다는 것을 잘 나타나는 지표로 사용할 수 있기 때문이다. 매일 1일 1커밋으로 Github에 잔디 심는(?) 행동도 성실하다고 표현할 수 있지만, 난 개인적으로 기술 블로그가 더 나랑 잘 맞아서 블로그를 꾸준히 하려고 노력하고 있다.블로그는 대학교 다니면서 한 교수님께서 네이버 블로그를 통해서 공부한 것을 기록하라고 수업 시간마다 작성하게 하면서부터 시작했다. 지금도 그 네이버 블로그는 아직 살아있지만, 단순히 백업 용도로만 사용하고 있다. 그다음에는 티스토리가 유행이어서 티스토리 썼는데, 지금 다시 보니 취업 준비하면서 글을 쓰고, 첫 회사 입사하고 나서 초반에 쓰다가 바빠지면서 지금 안 쓰게 되었다.다시 2019년에 들면서 GitHub Page 라는 것을 이용해서 블로그를 만들 수 있다는 내용을 듣고 리파지토리 새로 만들면서 기술 블로그를 지금까지도 잘 쓰고 있다. 처음에는 깔끔한 UI를 좋아해서 찾다가 texture jekyll 테마를 적용했다. 아직 초반이기 때문에 필요한 것들이 많지 않아서 해당 테마를 입히고 천천히 custom 하려고 했다. 대학교 때 배웠던 html이나 css로 웹사이트 만든 적도 있고, jekyll document도 잘 나와 있어서 참고하면서 천천히 나만의 기술 블로그로 만들려고 했다.깃헙 블로그 테마를 처음 적용한 모습커스텀하는게 재밌어서 블로그 작성하고 나면 ‘이런 부분은 좀 개선해야겠다’, ‘이런 거 추가해야겠다’ 하는 것을 메모했다가 시간 내서 적용하고 블로그 글을 작성하기도 했다. 이때까지만 해도 재미가 있었다.커스텀하는거는 재미있지만 오래가지 못했다이전에 썼던 테마에서 마지막으로 커스텀하면서 추가한 기능이 ‘태그’ 추가였다. 멋진 개발자들의 블로그를 보면 블로그 내용과 관련한 태그도 같이 나오길래 나도 한번 적용해보고 싶어서 추가해보려고 했다. 해당 테마는 태그 기능이 없길래 기능을 추가하면서 jekyll 문법도 보고, 회사 직원 도움받으면서 태그 기능을 추가했다. 생각보다 조금 어려웠고, 태그별로 또 페이지를 만들어야 하는 번거로움이 생겼다. 그래도 뭔가 스스로 하나를 만들었다는 기쁨에 좋았고 나중에는 ‘WWDC’ 카테고리를 따로 만들어서 확장하기도 했다.태그를 목록에 표시하고 어떤 태그냐에 따라서 색깔도 지정했다.문제는 여기서부터 시작했다. 커스텀 하는 부분에 생각보다 시간이 오래 걸렸고, 하다 보면 더 하고 싶은 부분과 번거로움이 생긴다는 점을 느꼈다. 개발자이다 보니 기능 하나 추가하거나 커스텀 하는 부분에서 재미를 느꼈지만, 이 부분에 대해서 꾸준히 해야 하는지 고민을 하기 시작했다. 블로그 글을 꾸준히 써야 하는데 커스텀까지 신경 써야 하기 때문이다. 회사 업무가 많아지다 보면 자연스레 커스텀 하는 부분은 나중에 생각하게 되고 귀찮아서 안 하게 되는 경우가 생기게 된다.최근에는 개인적으로 글 쓰는 것에 집중하자는 생각이 들면서 내가 만들고자 하는 블로그의 기능들이 있는 테마로 바꿔야겠다고 생각했다. 커스텀 하는 시간을 줄이고, 내가 필요한 기능들이 있는 테마로 바뀌게 되면 글 쓰는 것에만 집중할 수 있게 된다. 우연히 자주 보는 기술 블로그의 테마가 jekyll 테마여서 데모 사이트도 확인해보고, 내가 원하는 ‘카테고리’, ‘태그’, ‘글을 읽는 데 얼마나 걸릴지 표시’, ‘공유’ 등들이 있어서 바로 적용해봤다. 적용하는 데 하루가 걸렸지만, 결과는 만족스러웠다. 오죽하면 SNS에 관련해서 글을 올렸다.New theme to my Github Page ✨ pic.twitter.com/i8CAejd71s&mdash; Joohee Kim (@_jooheekim_) February 27, 2021기술 블로그에 글 쓰는 것에 집중하자기술 블로그에 글 쓰는 것에 집중해야 한다면, 커스텀 할 필요가 없는 테마를 적용하고 그 시간을 아끼자. 커스텀 하는 것도 좋지만, 커스텀 해야 한다면 시간을 투자해야 하는데, 회사에 다니고 있다면 시간을 낼 수 있을지 확실하지 않을 수 있다. 회사 업무가 바빠지면 개인 시간이 줄어들 수 있고, 그 시간을 회복하고자 주말에도 쉰다면 커스텀 할 수 있는 시간은 줄어들 수밖에 없다. 물론, 잠자는 시간을 줄여가면서 할 순 있지만, 개인적으로 난 그 시간에 블로그에 어떤 글을 쓸지 찾거나 글을 쓰는 시간으로 투자하고 싶다.사람마다 기술 블로그를 어떻게 운영하고 싶은지는 다를 수 있다. 커스텀 하면서 자신만의 색을 나타내는 블로그로 만들고 싶은 사람도 있고, 단순히 기술 블로그 운영하면 좋다고 해서 블로그만 만들고 글을 올리는 사람도 있을 것이다. 자신만의 취향에 맞춰서 기술 블로그 운영하면 되지만, 글 쓰는 것에 집중하고 싶다면, 글 쓰는 것에 집중할 수 있는 블로그 테마를 적용하자. 개인적으로 테마 바꾼 게 잘한 것이라고 하고 생각하고 있다. 시간 지나게 되면 커스텀 할 수 있는 부분이 생각이 나겠지만, 아직 그럴 시기는 안 온 것 같다." }, { "title": "Higher Order Functions: Filter, Map, Reduce", "url": "/posts/filter-map-reduce/", "categories": "", "tags": "swift", "date": "2021-03-02 00:00:00 +0000", "snippet": "There are some times we need to iterate an array or dictionary to collect or manipulate values. The easy way is using for-in loop, get a value and add or manipulate it to a new array. But Swift off...", "content": "There are some times we need to iterate an array or dictionary to collect or manipulate values. The easy way is using for-in loop, get a value and add or manipulate it to a new array. But Swift offers a great functions that makes it a little cleaner. These functions are called “Higer Order Functions”, and they are filter, map, reduce and more.It takes some time to get used to it. I personally try to use these functions, but doesn’t pop it right away while coding. So, I’m hopefully to get used to it writing this post. (Or comeback to remind it again 😅)FilterThe name of the function explains it, it returns an array containing the elements that satisfy the condition in order.// Filterlet familyNames = [\"Park\", \"Lee\", \"Jong\", \"Kim\", \"Choi\"]let longFamilyNames = familyNames.filter { $0.count &gt; 3 }print(longFamilyNames)// [\"Park\", \"Jong\", \"Choi\"]// For-in looplet familyNames = [\"Park\", \"Lee\", \"Jong\", \"Kim\", \"Choi\"]var longFamilyNames = [String]()for familyName in familyNames { if familyName.count &gt; 3 { longFamilyNames.append(familyName) }}print(longFamilyNames)// [\"Park\", \"Jong\", \"Choi\"]Complexity: O(n), where n is the length of the sequence.MapMap method returns an array that is filtered and manipulated. If you want to manipulate a value in an array for a new array, use map.// Maplet prices: [Double] = [400, 350, 150, 225, 500]let totalPricesWithTax = prices.map { $0 * 1.05 }print(totalPricesWithTax)// [420.0, 367.5, 157.5, 236.25, 525.0]// For-in looplet prices: [Double] = [400, 350, 150, 225, 500]var totalPricesWithTax = [Double]()for price in prices { totalPricesWithTax.append(price * 1.05)}print(totalPricesWithTax)// [420.0, 367.5, 157.5, 236.25, 525.0]ReduceUse reduce method to combine all values to create a single value, like the sum of all the value. An initial value and a combine closure is required when using reduce.// Filterlet prices: [Double] = [420.0, 367.5, 157.5, 236.25, 525.0]let totalPrice = prices.reduce(0.0, +)print(totalPrice)// 1706.25// For-in Looplet prices: [Double] = [420.0, 367.5, 157.5, 236.25, 525.0]var totalPrice: Double = 0for price in prices { totalPrice += price}print(totalPrice)// 1706.25let numbers = [1, 2, 3, 4]let numberSum = numbers.reduce(0) { x, y in x + y }print(numberSum)// 10Complexity: O(n), where n is the length of the sequence.When using filter, map, reduce methods, the returned array is immutable.Gist: https://gist.github.com/imjhk03/7c11c541b2bc69ba75f558f90d00b48d" }, { "title": "How to Join an Array of Strings", "url": "/posts/how-to-join-array-of-strings/", "categories": "Tips", "tags": "swift, array", "date": "2021-03-01 00:00:00 +0000", "snippet": "Using joined() method, we can merge an array of strings to a single string. We can add a separator too.let names = [\"Brian\", \"Nick\", \"John\", \"David\"]let list = names.joined(separator: \", \")print(li...", "content": "Using joined() method, we can merge an array of strings to a single string. We can add a separator too.let names = [\"Brian\", \"Nick\", \"John\", \"David\"]let list = names.joined(separator: \", \")print(list)// \"Brian, Nick, John, David\"" }, { "title": "iOS 14부터 달라진 앱에서 이메일 보내는 방법", "url": "/posts/ios14-how-to-send-email/", "categories": "", "tags": "iOS", "date": "2021-02-22 00:00:00 +0000", "snippet": "iOS 14에서는 기본 이메일 앱이 아닌 다른 서드파티 앱을 기본 이메일로 설정할 수 있습니다. 즉, 지메일, Outlook, Spark 등의 메일 앱을 이제 기본 이메일 앱으로 대체할 수 있습니다.이로 인해 앱에서는 기본적으로 메일 앱으로 보내는 방식에서, 대응할 앱을 추가로 보낼 방법을 지원해야 합니다. 예를 들어, 앱을 사용하다가 버그 혹은 문의...", "content": "iOS 14에서는 기본 이메일 앱이 아닌 다른 서드파티 앱을 기본 이메일로 설정할 수 있습니다. 즉, 지메일, Outlook, Spark 등의 메일 앱을 이제 기본 이메일 앱으로 대체할 수 있습니다.이로 인해 앱에서는 기본적으로 메일 앱으로 보내는 방식에서, 대응할 앱을 추가로 보낼 방법을 지원해야 합니다. 예를 들어, 앱을 사용하다가 버그 혹은 문의에 대해서 이메일 보내기를 했을 때, 사용자가 기본 메일 앱이 있으면 기본 메일 앱으로 보내지만, 없다면 지메일 혹은 다른 서드파티 이메일 앱을 통해서 보낼 수 있게 해야 합니다. 만약 사용자가 사용하는 이메일 앱에 대응할 수 없다면 안내 팝업을 띄워주면 사용자가 다른 방법을 통해서 이메일 보낼 수 있게 안내해주면 좋을 것 같습니다. 오늘 글에서 어떻게 코드를 작성할지 소개하겠습니다.기본 이메일 앱으로 보내는 방법이메일 구성 인터페이스애플에서 제공하는 라이브러리 중에 MessageUI 프레임워크 안에 MFMailComposeViewController를 이용해서 기본 이메일 앱을 통해서 이메일 보내는 것을 다룹니다. 받는 사람, 제목, 메시지 내용을 담아서 화면을 보여주지만, 이메일을 보내지 않습니다. 사용자가 보내기 액션을 취하면 그때 이메일이 보내집니다. 아래 예제 코드입니다.import MessageUIclass ViewController: UIViewController { ... func sendEmail() { let composer = MFMailComposeViewController() let receiver = \"imjhk03@gmail.com\" let subject = \"Bug report: \" let appVersion = Bundle.main.infoDictionary?[\"CFBundleShortVersionString\"] ?? 1.0 // 앱 버전 let osVersion = UIDevice().systemVersion // 기기의 os 버전 let message = \"\"\" Hello, App Version: \\(appVersion) iOS Version: \\(osVersion) \"\"\" if MFMailComposeViewController.canSendMail() { composerVC.mailComposeDelegate = self // Configure the fields of the interface. composerVC.setToRecipients([receiver]) composerVC.setSubject(subject) composerVC.setMessageBody(message, isHTML: false) // Present the view controller modally. present(composer, animated: true, completion: nil) } else { // show failure alert } }}이메일을 보내는 동작을 하는 Swift 파일에서 import MessageUI를 추가하고 MFMailComposeViewControllerDelegate 프로토콜을 적용해야 합니다. 이메일 작성 화면을 보여주기 전에 항상 canSendMail 함수를 이용해서 사용자의 기기에서 이메일을 보낼 수 있는지 판단합니다. 보낼 수 없다면 사용자에게 안내해줍니다. 추가로 앱 버전 혹은 iOS 버전과 같이 필요한 정보들이 있을 수 있는데, 앱 버전은 Bundle에서 가져오고, iOS 버전은 UIDevice에서 가져올 수 있습니다.MFMailComposeViewControllerDelegat 프로토콜을 적용해야 이메일 작성 화면을 dismiss 처리할 수 있는데, 바로 mailComposeController(_:didFinishWith:error:) 함수 안에서 dismiss 처리를 해야 합니다. 그리고 응답에 따라서 추가 액션을 취할 수 있습니다. (성공했을 때 성공 안내 메시지 노출 등)// MARK: - MFMailComposeViewControllerDelegateextension ViewController: MFMailComposeViewControllerDelegate { func mailComposeController(_ controller: MFMailComposeViewController, didFinishWith result: MFMailComposeResult, error: Error?) { // Check the result or perform other tasks. if result == .sent { } else { } // Dismiss the mail compose view controller. controller.dismiss(animated: true) }}서드파티 메일 앱으로 보내는 방법다른 방법으로 이메일 작성하는 것은 mailto 스킴을 이용해서 URL을 만들고 엽니다. 만든 URL을 이용해서 다른 앱을 열어서 메일을 보내는 방법입니다. 예시 코드는 Gmail, Microsoft Outlook, 그리고 Spark 앱 url 만드는 방법입니다.let subjectEncoded = subject.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed) ?? subjectlet bodyEncoded = body.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed) ?? body let gmailUrl = URL(string: \"googlegmail://co?to=\\(receiver)&amp;subject=\\(subjectEncoded)&amp;body=\\(bodyEncoded)\")let outlookUrl = URL(string: \"ms-outlook://compose?to=\\(receiver)&amp;subject=\\(subjectEncoded)&amp;body=\\(bodyEncoded)\")let sparkUrl = URL(string: \"readdle-spark://compose?recipient=\\(receiver)&amp;subject=\\(subjectEncoded)&amp;body=\\(bodyEncoded)\")URL을 이용해서 앱을 여는 방법이기 때문에 Info.plist 에서 관련 스킴을 추가해야 열 수 있습니다.&lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt;&lt;array&gt; &lt;string&gt;googlegmail&lt;/string&gt; &lt;string&gt;ms-outlook&lt;/string&gt; &lt;string&gt;readdle-spark&lt;/string&gt;&lt;/array&gt;앱에서 열 수 있는지 판단을 하고 열 수 있는 메일 앱 URL을 사용하면 됩니다. AlertSheet를 이용해서 사용 가능한 이메일 앱의 목록을 보여주고 선택하면 해당 이메일 앱으로 가도록 하는 방법을 사용하겠습니다. 목록으로 나타날 때 표시하는 제목과 URL을 묶은 tuple로 만들고, 앱에서 열 수 있는 앱들 목록을 canOpenURL(_:)을 이용해서 걸러냈습니다.let sendViaGmail = (url: gmailUrl, title: \"Gmail\")let sendViaOutlook = (url: outlookUrl, title: \"Outlook\")let sendViaSpark = (url: sparkUrl, title: \"Spark\") let availableApps = [sendViaGmail, sendViaOutlook, sendViaSpark].filter { availableApp -&gt; Bool in guard let url = availableApp.url else { return false } return UIApplication.shared.canOpenURL(url)}열 수 있는 앱들 목록을 이용해서 alertSheet을 만들어서 보여주거나, 만약 열 수 있는 앱들이 없다면 이메일을 보낼 수 없는 안내 alert를 보여주도록 하겠습니다. AlertSheet 목록에서 선택하면 open(_:options:completionHandler:) 이용해서 앱을 엽니다. Info.plist에 설정되어 있지 않으면 아무 동작하지 않기 때문에 꼭 설정해주세요.guard !availableApps.isEmpty else { presentAlertCanNotSendEmail() return} presentAlertSheetThirdPartyEmailApps(availableApps)... private func presentAlertCanNotSendEmail() { let alert = UIAlertController(title: \"Alert\", message: \"It seems there is no way to send email in your device. Please send email to bugReport@email.com\", preferredStyle: .alert) alert.addAction(UIAlertAction(title: \"OK\", style: .default)) present(alert, animated: true)} private func presentAlertSheetThirdPartyEmailApps(_ availableApps: [AvailableApps]) { let alert = UIAlertController(title: nil, message: nil, preferredStyle: .actionSheet) for app in availableApps { alert.addAction(UIAlertAction(title: app.title, style: .default, handler: { _ in guard let url = app.url else { return } UIApplication.shared.open(url, options: [:], completionHandler: nil) })) } alert.addAction(UIAlertAction(title: \"Cancel\", style: .cancel, handler: nil)) present(alert, animated: true)}적용해보면 아래와 같은 스크린샷 모습을 볼 수 있습니다.Warning: 이메일 앱을 보내는 것을 테스트하고 싶다면 iOS 시뮬레이터가 아닌 실 기기에서 테스트해야 합니다.iOS 14에서부터 서드파티 앱을 기본 이메일 앱을 설정할 수 있는데, 이로 인해 대응할 방법을 소개했습니다. 전체 코드를 보고 싶다면 깃헙에서 확인할 수 있습니다." }, { "title": "How to send emails from iOS 14", "url": "/posts/ios14-how-to-send-email-eng/", "categories": "", "tags": "iOS", "date": "2021-02-22 00:00:00 +0000", "snippet": "With iOS 14, third-party app can be the default email app. This means we may have to support sending email with third-party apps. If the user is not using the default email app and use another app ...", "content": "With iOS 14, third-party app can be the default email app. This means we may have to support sending email with third-party apps. If the user is not using the default email app and use another app like gmail, we may need to handle to open gmail app to send email. Let’s see how to do this.How to send email via defaultEmail composition InterfaceApple’s MessageUI framework provides MFMailComposeViewController which shows an email composition interface to send email inside an app. Although this does not automatically send email, so the user need to tap themselves to send email. Here is the example code below.import MessageUIclass ViewController: UIViewController { ... func sendEmail() { let composer = MFMailComposeViewController() let receiver = \"imjhk03@gmail.com\" let subject = \"Bug report: \" let appVersion = Bundle.main.infoDictionary?[\"CFBundleShortVersionString\"] ?? 1.0 // App version let osVersion = UIDevice().systemVersion // os version let message = \"\"\" Hello, App Version: \\(appVersion) iOS Version: \\(osVersion) \"\"\" if MFMailComposeViewController.canSendMail() { composerVC.mailComposeDelegate = self // Configure the fields of the interface. composerVC.setToRecipients([receiver]) composerVC.setSubject(subject) composerVC.setMessageBody(message, isHTML: false) // Present the view controller modally. present(composer, animated: true, completion: nil) } else { // show failure alert } }}You need to import MessageUI and conform to MFMailComposeViewControllerDelegate protocol. Make sure to check if the user device can send email with canSendMail() function. Additionally, we can also get the app’s version or the device os version with Bundle or UIDevice.To dismiss the email composition interface, we need to conform MFMailComposeViewControllerDelegate protocol. In mailComposeController(_:didFinishWith:error:) function we dismiss the view controller. We can also handle if the email has sent or cancelled to do more tasks.// MARK: - MFMailComposeViewControllerDelegateextension ViewController: MFMailComposeViewControllerDelegate { func mailComposeController(_ controller: MFMailComposeViewController, didFinishWith result: MFMailComposeResult, error: Error?) { // Check the result or perform other tasks. if result == .sent { } else { } // Dismiss the mail compose view controller. controller.dismiss(animated: true) }}How to send email via third party appsThe other way to send email is to create URL with mailto scheme and open it. Below code shows the URL with Gmail, Microsoft Outlook, and Spark app.let subjectEncoded = subject.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed) ?? subjectlet bodyEncoded = body.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed) ?? body let gmailUrl = URL(string: \"googlegmail://co?to=\\(receiver)&amp;subject=\\(subjectEncoded)&amp;body=\\(bodyEncoded)\")let outlookUrl = URL(string: \"ms-outlook://compose?to=\\(receiver)&amp;subject=\\(subjectEncoded)&amp;body=\\(bodyEncoded)\")let sparkUrl = URL(string: \"readdle-spark://compose?recipient=\\(receiver)&amp;subject=\\(subjectEncoded)&amp;body=\\(bodyEncoded)\")To open the URL, we need to set LSApplicationQueriesSchemes in the Info.plist.&lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt;&lt;array&gt; &lt;string&gt;googlegmail&lt;/string&gt; &lt;string&gt;ms-outlook&lt;/string&gt; &lt;string&gt;readdle-spark&lt;/string&gt;&lt;/array&gt;We are going to use AlertSheet to show apps that can open the URL. By using the canOpenURL(_:) function, we check and filter the third party apps that the app can open. Then make a tuple to store the URL and the name.let sendViaGmail = (url: gmailUrl, title: \"Gmail\")let sendViaOutlook = (url: outlookUrl, title: \"Outlook\")let sendViaSpark = (url: sparkUrl, title: \"Spark\") let availableApps = [sendViaGmail, sendViaOutlook, sendViaSpark].filter { availableApp -&gt; Bool in guard let url = availableApp.url else { return false } return UIApplication.shared.canOpenURL(url)}After selecting any apps from the AlertSheet, the open(_:options:completionHandler:) function will open the third party app to send email. If there are no apps that the app can open, we are going to show a failure alert.guard !availableApps.isEmpty else { presentAlertCanNotSendEmail() return} presentAlertSheetThirdPartyEmailApps(availableApps)... private func presentAlertCanNotSendEmail() { let alert = UIAlertController(title: \"Alert\", message: \"It seems there is no way to send email in your device. Please send email to bugReport@email.com\", preferredStyle: .alert) alert.addAction(UIAlertAction(title: \"OK\", style: .default)) present(alert, animated: true)} private func presentAlertSheetThirdPartyEmailApps(_ availableApps: [AvailableApps]) { let alert = UIAlertController(title: nil, message: nil, preferredStyle: .actionSheet) for app in availableApps { alert.addAction(UIAlertAction(title: app.title, style: .default, handler: { _ in guard let url = app.url else { return } UIApplication.shared.open(url, options: [:], completionHandler: nil) })) } alert.addAction(UIAlertAction(title: \"Cancel\", style: .cancel, handler: nil)) present(alert, animated: true)}If you apply it, you can see the screenshot like below.WARNING: If you want to test sending an email app, you need to test it on a real device, not on an iOS simulator.From iOS 14, third-party apps can be set as default email apps, and this post introduce how to support it. If you want to see the full code, check it on GitHub." }, { "title": "Get an Array of Dictionary's keys or values", "url": "/posts/dictionary-key-value-array/", "categories": "Tips", "tags": "swift", "date": "2021-02-15 00:00:00 +0000", "snippet": "If you need an array of keys or values of a dictionary, Swift has an easy way to do it.// You can get an array of dictionary's key or valueslet grades = [\"KOR\": 82, \"ENG\": 98, \"MATH\": 90]let subjec...", "content": "If you need an array of keys or values of a dictionary, Swift has an easy way to do it.// You can get an array of dictionary's key or valueslet grades = [\"KOR\": 82, \"ENG\": 98, \"MATH\": 90]let subjects = [String](grades.keys)// [\"KOR\", \"ENG\", \"MATH\"]let scores = [Int](grades.values)// [82, 90, 90]" }, { "title": "Fork한 Repository Sync하기 (동기화하기)", "url": "/posts/how-to-sync-fork-repository/", "categories": "", "tags": "git", "date": "2021-02-06 00:00:00 +0000", "snippet": "예전에는 리파지토리를 fork 해서 사용해 본 적이 드물었는데, 최근에는 fork 해서 개인 리파지토리에서 개발하다가 upstream 리파지토리로 반영하는 일이 잦아들었다. 그래서 개발하다 보면 최신 상태로 동기화 작업을 해야 하는데 맨날 까먹어서 글로 남기려고 한다. 터미널 연다. 작업하고 있는 리파지토리 경로로 이동한다. upstream 리파...", "content": "예전에는 리파지토리를 fork 해서 사용해 본 적이 드물었는데, 최근에는 fork 해서 개인 리파지토리에서 개발하다가 upstream 리파지토리로 반영하는 일이 잦아들었다. 그래서 개발하다 보면 최신 상태로 동기화 작업을 해야 하는데 맨날 까먹어서 글로 남기려고 한다. 터미널 연다. 작업하고 있는 리파지토리 경로로 이동한다. upstream 리파지토리의 브랜치들을 fetch한다. $ git fetch upstream fork한 리파지토리의 로컬 기본 브랜치로 이동한다. 예를 들면 master 혹은 main. $ git checkout main upstream 기본 브랜치를 병합한다. $ git merge upstream/main " }, { "title": "Comparable enum", "url": "/posts/comparable-enum/", "categories": "", "tags": "swift", "date": "2021-01-25 00:00:00 +0000", "snippet": "From Swift 5.3 and later, enums can be comparable. We can compare two cases from the enum with &gt;, &lt; and similar.enum Sizes: Comparable { case S case M case L}let first = Sizes.Slet s...", "content": "From Swift 5.3 and later, enums can be comparable. We can compare two cases from the enum with &gt;, &lt; and similar.enum Sizes: Comparable { case S case M case L}let first = Sizes.Slet second = Sizes.Lprint(first &lt; second)// will print true, S comes before L in the enum case listEnums with associated values can also be comparable.enum OrderStatus: Comparable { case purchased case readyToShip case shipping(progress: Int) case shippingComplete}let orderStatusList = [shippingComplete, readyToShip, shipping(progress: 0.5), shipping(progress: 0.3), purchased]let sortedByStatus = orderStatusList.sorted()print(sortedByStatus)// purchased, readyToShip, shipping(progress: 0.3), shipping(progress: 0.5), shippingCompleteIn the above example, array will be sorted similar with the enum case list. But shipping(progress: 0.5) will consider to be higher than shipping(progress: 0.3).RefrenceSynthesized Comparable conformance for enum types" }, { "title": "How to show build times in Xcode", "url": "/posts/how-to-show-build-times-in-xcode/", "categories": "Tips, Xcode", "tags": "xcode", "date": "2021-01-17 00:00:00 +0000", "snippet": "You can show how long the project build in Xcode by entering below command in Terminal.app.defaults write com.apple.dt.Xcode ShowBuildOperationDuration YESAfter entering the command, if you build X...", "content": "You can show how long the project build in Xcode by entering below command in Terminal.app.defaults write com.apple.dt.Xcode ShowBuildOperationDuration YESAfter entering the command, if you build Xcode it will show the build time on the activity viewer.If you change YES to NO, the build time will not show in Xcode." }, { "title": "Multiline string literal tips", "url": "/posts/multiline-string-literal-tips/", "categories": "Tips", "tags": "swift, strings", "date": "2021-01-10 00:00:00 +0000", "snippet": "In Swift, we can use multiline string literal to express several lines of string. Although, adding the new line character \\n can create line break, it only works for string that are displayed. Use ...", "content": "In Swift, we can use multiline string literal to express several lines of string. Although, adding the new line character \\n can create line break, it only works for string that are displayed. Use multitline strings for formatting string nicely.let quotation = \"\"\"We can make multi-line strings.Use three double quotation marks.Also, multi-line strings can write \"quote marks\"\"\"\"When using multiline string, always start and end the content using \"\"\" on single line.let badMultilineString = \"\"\"This will not create multi-line string.Always start with an new line and end before a new line.\"\"\"let goodMultilineString = \"\"\"This will create multi-line string.Always start with an new line and end before a new line.\"\"\"We can also add backslash \\ for reading a very long string a bit easier. This will not change the value.let veryLongString = \"\"\"Lorem Ipsum is simply dummy text of the printing and typesetting industry.Lorem Ipsum has been the industry's standard dummy text ever \\since the 1500s, when an unknown printer took a galley of \\type and scrambled it to make a type specimen book.\"\"\"We can indent strings in multiline string. The indent will start at the closing quotation marks \"\"\", before will be ignored. So in the following code, the second string will have indents.let linesWithIndent = \"\"\" This line doesn't have indents. This line has indents. This line also doesn't have indents. \"\"\"When building a longer strings with multiline string literals, every line in the string needs to end with a line break.let badStart = \"\"\"onetwo\"\"\"let end = \"\"\"three\"\"\"print(badStart + end)// Prints two lines:// one// twothreelet goodStart = \"\"\"onetwo\"\"\"print(goodStart + end)// Prints three lines:// one// two// three" }, { "title": "Underscores as thousands separators", "url": "/posts/underscores-as-thousands-separators/", "categories": "Tips", "tags": "swift", "date": "2021-01-05 00:00:00 +0000", "snippet": "When using large Int numbers, we can use underscores as thousands separators to make it easier to read.let love = 3_000var population = 9_000_000", "content": "When using large Int numbers, we can use underscores as thousands separators to make it easier to read.let love = 3_000var population = 9_000_000" }, { "title": "주니어 개발자의 마지막, 미드레벨(mid-level) 개발자의 시작", "url": "/posts/junior-developer-end-mid-level-start/", "categories": "Blog", "tags": "blog", "date": "2020-12-26 00:00:00 +0000", "snippet": "이제 곧 4년 차, 미드 레벨(mid-level) 개발자가 될 예정이다. 생각보다 빠르게 시간이 지난 것 같다. 3년의 개발 생활을 회고하면서 그동안 나는 어떤 일을 했고, 앞으로는 어떤 방향으로 개발하고 싶은지 정리하고자 이 글을 쓰게 되었다.실무 경험을 배우고 익숙해지는 시기입사하고 나서 약 1년 6개월 동안은 시니어 개발자와 함께 개발하면서 실무...", "content": "이제 곧 4년 차, 미드 레벨(mid-level) 개발자가 될 예정이다. 생각보다 빠르게 시간이 지난 것 같다. 3년의 개발 생활을 회고하면서 그동안 나는 어떤 일을 했고, 앞으로는 어떤 방향으로 개발하고 싶은지 정리하고자 이 글을 쓰게 되었다.실무 경험을 배우고 익숙해지는 시기입사하고 나서 약 1년 6개월 동안은 시니어 개발자와 함께 개발하면서 실무 업무를 익히고, 조금씩 업무량을 늘리는 시간을 보낸 것 같다. 그동안 1명이 운영하던 앱을 2명에서 개발을 하게 되니깐 주니어인 나는 시니어 개발자의 코드를 보고 배우는 시간을 보냈다. 시니어 개발자는 앱 서비스 개발하면서 내가 잘 따라올 수 있는지 확인해보는 시간을 보냈다. 여러 가지 미션들을 수행하면서 앱의 전체적인 구조를 조금 맛볼 수 있었고, 실무에서는 이렇게 사용하는구나 하고 배울 수 있었다. 다행히 나는 빠르게 실무 일할 수 있다고 판단되어 한 달 만에 실무 업무를 하기 시작했다. 아직도 기억나는 나의 첫 업무는 위로 가기 버튼 이미지 변경하고 모양을 바꾸는 작업이었다. 작업 후에 앱 버전 배포되었을 때도 기억나는 게, 내가 작성한 코드가 있는 앱이 세상에 나온 것만으로 너무 좋았다. 비록 수많은 코드 중에 몇 줄이겠지만, 뭔가 하나를 했다는 거에 뿌듯함을 느꼈다.시간 지날수록 조금씩 업무를 늘려가면서, 나는 욕심이 조금씩 생겼다. 화면의 일부분만 작업하다가 화면 전체도 작업하게 되고, 처음 안 만들어본 기능도 개발하게 되었다. iMessage app이랑 Watch App 등, 여러 가지 새로운 기능들을 개발하면서 도입하고, 어떤 하나의 피쳐(feature)를 담당하는 매니저(Manager) 혹은 wrapper 클래스도 개발해봤다. 그러면서 첫 벽에 부딪히고 어려워하다가 혼자 깨트리고, 하나의 업데이트 버전(거의 개편 수준)을 혼자서 개발해 본 경험도 했다. 중간중간에도 기술 블로그 글도 썼다. 조금씩 할 수 있는 게 많아지다 보니, 자연스레 앱에 대한 이해도가 높아지고 앱 개발 외적인 배포 프로세스나 기타 등등에도 관심 두게 되었다. 앱 배포 경험은 사내 앱용으로 개발해서 배포한 적이 있었는데, 앱 스토어에 앱을 등록해서 배포한 경험은 회사 다니면서 알게 되었다. 배포에 필요한 것들과 준비하는 등 여러 가지 등을 메모해 가면서 언젠가 새로운 앱 서비스를 개발하게 된다면, 잘 할 수 있도록 준비를 했다.iOS 파트를 이끌다그리고 생각보다 빠르게, 시니어 개발자의 육아 휴직으로 인해 iOS 파트를 이끌어야 하는 시기가 왔다. ‘혼자서 잘할 수 있지?’ 무심코 던진 시니어 개발자의 말에 왠지 모르게 준비를 한 나 자신이 다행이라고 생각했다. 물론, 두렵긴 했다. 이제 1년이 지났는데, 아직 더 배울 게 많다고 생각하는데, 혼자서 iOS 파트를 이끌어야 하고 잘 할 수 있을지 무서웠다. 일단 부딪혀 보자 하는 심정으로 신입 개발자도 뽑아서 혼자 업무 부담을 많이 받지 않도록 했다. 물론 신입 개발자가 자기의 역량만큼 일하려면 시간이 오래 걸리겠지만, 일단 상황은 이렇게 되었기 때문에 감안하고 하루하루를 보냈다.약 8개월의 시간은 솔직히 고통스러웠다. 일단 개발뿐만 아니라 관리까지 해야 했기 때문에, 업무량이 기본 2배였다. 개발만 신경 써야 하는 게 아니라, 앞으로 개발해야 하는 것들이 가능한지 검토해야 하고, 개발부터 테스트, 배포까지의 업무 프로세스를 알아야 하고, 앱 스토어와 관련된 내용, 가이드라인 등 개발 외적인 내용을 알고 있어야 했다. 게다가 신입 개발자가 회사에 잘 적응하고 업무 일을 할 수 있도록 옆에서 신경도 써야 했다. 흰머리는 입사했을 때부터 나긴 했는데, 이 기간에는 계속 한쪽에서 많이 나기 시작했다. 잠드는 시간은 보통 새벽 2시에서 4시 사이, 조금 심하면 6시에 자서 1시간 자고 일어나서 출근했다. 늘 퇴근해서도 공부하는 습관이 조금 있었지만, 공부는 기본이고 업무까지 해야 하는 상황이 거의 일상이었다. 그리고 하필 이럴 때, 새로운 앱 서비스를 출시해야 했다. 총 3개의 앱 서비스를 운영해야 했다. 개발 외적인 뭔가가 필요하다는 것을 느꼈다.도구와 문화 도입iOS 파트 이끌기 시작했을 때, 어떤 체계가 필요하다고 생각했다. iOS 파트나 팀 안에서 공유하는 문서나 기타 내용은 주로 슬랙 채널이나 노션 문서로 공유하지만, 나는 조금 더 iOS 파트 내에서 관리하는 도구가 필요하다는 것을 느꼈다. 그래서 iOS Workspace 라는 큰 노션 문서를 만들어, iOS 파트 내에 필요한 것들을 조금씩 정리하기 시작했다. 시니어 개발자가 육아 휴직하기 전, 작성한 아키텍처 혹은 iOS 프로젝트 관련 문서들을 이 workspace 문서에 옮겼고, 하나의 스프린트 작업할 때마다 기록하는 문서 등을 만들었다. 그리고 이 워크스페이스 문서는, 지금까지도 쭉 관리하고 사용하고 있다.신입 개발자와 협업하면서 조금이라도 더 나은 개발자로 성장할 수 있도록 여러 가지 공부 내용 공유도 했지만, 개인적으로 제일 많이 도움 준 거는 코드 리뷰라고 생각한다. 개인적으로 코드 리뷰가 중요하다고 생각했고, 시니어 개발자와 둘이서 작업할 때도 종종 시니어 개발자의 코드 리뷰 받으면서 많이 고치고 배우기도 했었다. 내가 신입 개발자의 코드를 리뷰하면서 더 나은 코드 방향으로 수정할 수 있도록 도와주고, 개발한 내용을 이해하는지도 확인할 수 있었다. 그러면서 반대로 신입 개발자도 내 코드 보면서 어떤 내용인지 확인하고, 왜 이렇게 작성했는지 물어보면 대답할 수 있도록 하는 시간도 가졌다. 나도 내 코드가 완벽하지 않을 수 있기 때문에, 서로 코드를 봐주면서 하면 예상치 못한 버그를 찾거나, 더 나은 코드로 작성할 수 있다.코드 리뷰하면서 GitFlow 브랜치 방법을 도입했다. 그 전에 사용한 브랜치 방법이 있었지만, 엔터프라이즈 용 앱 개발할 때 자동 빌드와 배포에 사용했던 브랜치 방법이었고, 나는 이 자동화 빌드까지 신경 쓸 여력이 없었다. 그래서 새롭게 GitFlow 브랜치 도입을 했고, iOS 파트랑 맞게끔 조금 수정해서 적용하여 지금까지도 잘 쓰고 있다. 관련하여 문서도 만들어서 안드로이드 파트와 공유하는 시간도 가졌다. 주 단위로 개발하는 작업의 진행 상태를 한눈에 볼 수 있는 Sprint 문서도 만들었다. 내가 개발하면서 신입 개발자의 개발 진행 상황도 보고 싶어서 도입했고, 주 단위로 자신이 해야 하는 일을 볼 수 있어서 서로 긍정적인 효과를 봤다.협업하기여러 도구와 문화가 도입했지만, 계속 쌓여가는 피로도는 결국 마지막에 나를 더 힘들게 했다. 중간 휴식을 취할 수 있게 매 차수 끝날 때 연차를 썼지만, 하루 이틀 가지고는 그동안 쌓인 피로도가 한 번에 풀리지 않다. 그리고 쉬고 있어도 이메일 알림 혹은 메신저 알림 들리기만 하면 심장이 쿵 내려앉으면서 무슨 일 있나 조마조마하면서 내용을 확인해야 했다. 업무 부담감을 나눠야 했다.팀에 시니어 개발자들이 대거 채용되면서 자연스레 iOS 파트를 더 이끌지 않게 되었다. 팀장님과 파트장님께서 자연스레 업무 부담감을 가져간 덕분에 피로도가 조금씩 낮아졌다. 숨 쉴 틈이 벌어지기 시작했다. 물론 중간에 급하게 추가 요청 사항이 생기거나, 갑자기 앞당겨진 완료 날짜가 생겼었다. 그런 문제가 발생하면 히스토리를 알고 빠르게 문제를 해결할 수 있는 내가 빠르게 처리했다.육아 휴직을 보내신 시니어 개발자까지 복귀하여 드디어 iOS 파트도 많은 개발자가 생겼다. 그동안 1~2명에서 2개의 앱 서비스 혹은 3개의 앱 서비스를 운영했었는데, 이제는 5명 이상으로 늘어났다. 자연스레 협업에 필요한 규칙도 서로 맞춰 가면서 진행했고, 골고루 업무 할당량이 주어지기 시작했다. 협업에 필요한 코드 리뷰는 사용하고 있는 소스 관리 시스템에 따라 한정적으로 사용할 수밖에 없었지만, 코드 리뷰하면서 서로 코드 보면서 수정이 필요한 부분을 찾아내거나 다른 사람의 코드를 보고 배울 수 있게 된다.코드 리뷰하면서 배우기그동안 1~2명에서 개발하게 되면 서로의 코드 스타일이 점점 비슷해질 수 있다. 새로운 개발 방법을 배우면 도입해보면서 할 수 있지만, 이것도 결국 오래 가지 못한다. 이번에 많은 개발자랑 협업하면서 코드 리뷰를 진행했는데, 다양한 코드 스타일과 방식을 배울 수 있어서 너무 좋았다. 1년 동안 배움에 대해 목말라 있던 나에게 너무 좋은 시간이었다. iOS 파트를 이끈 기간 동안 과연 내가 코드를 잘 작성했는지, 더 개선할 수 있는 게 없는지 항상 궁금했다. 신입 개발자 눈에는 잘 짜여 있을지 몰라도 시니어 개발자의 눈에는 달라 보일 수 있다. 나는 그런 피드백이 필요했다.그래서 다양한 개발자들의 PR 보면서 많이 배울 수 있었고, 내가 올린 PR에 대한 피드백도 받아 볼 수 있어서 내 안의 갈증이 해소된 느낌이 들었다. 당연히, 여기서 그치지 않고 나의 코드 스타일과 개선할 수 있는 모든 것들에 대해서 적용했다. 적용하는 시간이 조금 필요했지만, 적용하면서 니 자신도 이런 게 가능하구나 하고 깨달을 수 있었다.코드를 보면서 개발하기시니어 개발자 중 한 명이 이런 말을 했었다. ‘코드를 보면서 개발할 수 있게 되었다’. 업무 작업량이 골고루 잘 분배되면서 시간적 여유도 생겼다. 그러면서 자연스레 코드를 보면서 개발할 수 있게 되었다고 말씀하셨다. 나는 이 말에 공감이 되었다. 그동안 빠르게 기능 개발해야 할 때는, 동작이 잘 돌아가는 것을 확인하고 다음에 더 개선해야지 하면서 넘어간 적이 많았다. 솔직히 시간이 없었다. 회사 사정상 빠르게 기능 도입하고 업데이트해야 하는 상황이었다. 거기에 맞춰서 개발하게 되면 어쩔 수 없이 코드에 많은 시간을 투자할 수 없다. 일정을 맞추는 게 우선이기 때문이다.하지만 지금은 조금 더 여유롭게 기능 구현할 수 있는 일정이 되었다. 자연스레 코드 보는 시간이 많아졌고, 거기에 따라 더 개선할 수 없는 부분이 없나, 더 나은 방법이 없나 고민하는 시간도 늘어났다. 늘어나면서 더 나은 코드로 개발할 수 있게 된 것 같다. 지난번에 작성한 코드를 다시 보게 되면 개선할 수 있는 부분이 없나 확인해보고, 개선할 수 있으면 개선한다. 새로 개발하는 부분에 대해서 더 많은 자료를 찾는 시간도 가질 수 있고, 테스트하면서 개발할 수 있게 되었다. 코드 리뷰하면서 아이디어 얻게 되면, 그 아이디어를 가지고 개발하는 부분에 적용해보기도 한다. 개발하는 코드의 수준이 조금씩 나아지고 있다는 게 눈에 보이기 시작했다.더 나은 코드, 더 나은 개발자지난 3년 동안 정말 많은 경험을 했던 것 같다. 갓 신입 개발자로서 할 수 있는 일을 해보고, iOS 파트를 이끄는 경험도 해보고, 많은 개발자와 협업하는 경험도 했다. 틈틈이 개인 프로젝트 앱도 개발하고, 작지만 개인 블로그도 만들었다. 시간적 여유가 생기다 보니 코드를 보는 시간이 늘어났고, 그동안 개발한 코드를 보면서 개선할 수 있던 부분이 없었나 찾으면서 개선하는 시간을 가졌다. 바빠서 못 했던 일들을 조금씩 해보면서 앱 프로젝트의 퀄리티를 높이는 일에 힘을 더 썼다. 기능 개발은 나 말고 다른 개발자들이 할 수 있으니깐, 나는 앱 프로젝트의 퀄리티를 높이는 작업에 더 집중했다.그러면서 코드에 대한 나의 가치관도 조금씩 달라지는 게 느껴졌다. 멋진 기능들을 개발하고 멋지고 깨끗하고 똑똑한 코드를 개발하는 게 좋다고 생각했었다. 하지만 지금은 똑똑한 코드보다 읽기 좋은 코드가 더 좋다고 생각한다. 너무 똑똑한 코드는, 한 번에 이해하는 데 시간이 걸릴 수 있고, 잘 안 읽힐 수도 있다. 여러 번 봐야 아 이런 일을 하는구나 하고 깨닫거나, 이해 못 하고 사용하지 않게 되어 개발한 사람만 수정할 수 있게 될 수도 있다. 혼자만 똑똑해지는 코드다. 읽기 좋은 코드는 신입 개발자부터 시니어 개발자까지, 모든 사람이 한 번에 이해할 수 있고, 어디든지 사용할 수 있는 간단한 코드로 보인다.나는 앞으로도 읽기 좋은 코드, 더 나은 코드로 앱 프로젝트의 퀄리티를 높이는 개발자로 일하려고 한다. 기능 개발하면서 앱의 퀄리티를 높이는 코드를 개발해서, 신입 개발자와 시니어 개발자의 중간 다리 역할 하고 싶다. 읽기 좋은 코드로 그 다리를 만들어주고 싶다. 그 다리 만들면서 시니어 개발자로 성장하고 싶다." }, { "title": "How to round corners specifically on a UIView", "url": "/posts/round-corners-specific-view/", "categories": "Tips", "tags": "iOS, ui development", "date": "2020-11-17 00:00:00 +0000", "snippet": "To round a corner on a UIView, you can set the layer’s cornerRadius value. Simply use it like this:cornerView.layer.cornerRadius = 8cornerView.layer.clipsToBound = true // to make the corner wor...", "content": "To round a corner on a UIView, you can set the layer’s cornerRadius value. Simply use it like this:cornerView.layer.cornerRadius = 8cornerView.layer.clipsToBound = true // to make the corner work, clipsToBound must be trueBut what if you need to corner only to top view or bottom? We need to set the layer’s maskedCorners property. You can make an extension for making a rounded corner like this:extension UIView { // available from iOS 11.0 func roundCorners(_ corners: UIRectCorner, radius: CGFloat) { self.layer.cornerRadius = radius var cornerMask = CACornerMask() if corners.contains(.topLeft) { cornerMask.insert(.layerMinXMinYCorner) } if corners.contains(.topRight) { cornerMask.insert(.layerMaxXMinYCorner) } if corners.contains(.bottomLeft) { cornerMask.insert(.layerMinXMaxYCorner) } if corners.contains(.bottomRight) { cornerMask.insert(.layerMaxXMaxYCorner) } self.layer.maskedCorners = cornerMask }}" }, { "title": "How to create a view controller from xib", "url": "/posts/create-viewcontroller-from-xib/", "categories": "", "tags": "iOS, ui development, view controllers, storyboard", "date": "2020-11-09 00:00:00 +0000", "snippet": "Creating a new view controller was easy. I’ve used to create a view controller from Storyboard, and instantiated in code. Although this way is easy, so many view controllers in a Storyboard can inc...", "content": "Creating a new view controller was easy. I’ve used to create a view controller from Storyboard, and instantiated in code. Although this way is easy, so many view controllers in a Storyboard can increase compiling time. While working with new people in iOS team, there was a way to create a view controller from xib. Let’s see how to do it.1. Create a new xib fileFirst, create a new empty xib file and name it. Then, add a UIView to the empty place. Add other components you need.2. Create a swift fileCreate a swift file that associates with the new view controller xib file. Here are the start code for example.import UIKitfinal class MainViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() } }3. Link both filesNow let’s link both files. In the xib file, the File’s Owner is the swift file name. Put the view controller swift file name at the File’s Owner Custom Class &gt; Class.After that, you can add IBOutlets to the swift file. As you add the IBOutlets, you can see the object is File’s Owner below the screenshot. I added a new collection view and at viewDidLoad function, I set the collection view’s background color to red.import UIKitfinal class MainViewController: UIViewController { @IBOutlet weak var collectionView: UICollectionView! override func viewDidLoad() { super.viewDidLoad() collectionView.backgroundColor = .red } }4. Get the view controllerAfter everything is all set, let’s get the view controller and use it. It is very simple.let previousVC = MainViewController()self.present(previousVC, animated: true, completion: nil) // present or push as you wishBut when you build and run, the app will crash. And the console log will show the error like below.terminating with uncaught exception of type NSException*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: '-[UIViewController _loadViewFromNibNamed:bundle:] loaded the \"MainViewController\" nib but the view outlet was not set.'Why is this error occurring? We have forgotten to link the UIView itself to the file’s owner. This error was the common error I had while creating a xib for view controller. So let’s solve this problem.Go to the xib file and at the File’s Owner ‘s Connection Inspector, link the view object to the view in the Document Outline. See the image below for more details.Now build and run, and your app won’t crash and show the view controller successfully.How to get the view controller from Storyboard?Below code is how to create a view controller from Storyboard.let storyboard: UIStoryboard = UIStoryboard(name: \"Main\", bundle: nil)let authenticationVC: UIViewController = storyboard.instantiateViewController(withIdentifier: \"AuthenticationVC\") as UIViewControllerSummaryIn this post, I’ve explained how to create a view controller from xib file. From Apple’s document, if you specify the views for a view controller using a xib(nib) file, you can’t define segues or relationships between view controllers. Use wisely when creating a view controller from xib rather than storyboard." }, { "title": "Xcode 소소한 팁", "url": "/posts/xcode-tips/", "categories": "Tips, Xcode", "tags": "xcode", "date": "2020-11-02 00:00:00 +0000", "snippet": "Xcode 사용하면서 알게 된 소소한 팁들을 소개한다.1. Annotation을 잘 활용하자Xcode에서 TODO, MARK, FIXME Annotations이라는 것을 주석처럼 쓰면서 용도별로 사용할 수 있다. TODO - 이름 그대로 작업하면서 해야할 일들을 쓴다. MARK - 하나의 섹션 덩어리로 사용할 수 있다. 주로 영역 단위로 해당 영역...", "content": "Xcode 사용하면서 알게 된 소소한 팁들을 소개한다.1. Annotation을 잘 활용하자Xcode에서 TODO, MARK, FIXME Annotations이라는 것을 주석처럼 쓰면서 용도별로 사용할 수 있다. TODO - 이름 그대로 작업하면서 해야할 일들을 쓴다. MARK - 하나의 섹션 덩어리로 사용할 수 있다. 주로 영역 단위로 해당 영역이 무엇인지 표시한다. FIXME - 나중에 수정이 필요한 부분을 표시한다.Controller Outline에서는 아래와 같이 각 Annotation 아이콘이 달라 구별하면서 찾을 수 있다. 그 중에 MARK Annotation만 다른 annotation과 다르게 굵게 나타나고 위에 선이 나타나 조금 특이하다. Minimap에서는 영역별로 MARK 설명이 표시되어 찾기가 편하다.2. #warning을 잘 활용하자위에서 설명한 Annotation도 잘 활용하면 좋지만, 주석처럼 보이게 되어 작업하다 보면 까먹을 수 있다. 이때 #warning 혹은 #error를 잘 활용하면 좋다. #warning(Message) 내용을 작성하면, 빌드하면서 Issues Navigator에 노란색 warning 부분에 해당 내용이 나타난다. Warning을 하나씩 제거하면서 작업하면 어느새 TODO 리스트처럼 활용할 수 있다. #error는 warning과 비슷하지만 빌드가 안되는 차이가 있다.3. 검색한 결과들 중 필요없는 파일 숨기기Find Navigator에서 특정 단어 혹은 파일 이름을 사용한 부분들을 검색하면 생각보다 많은 검색 결과들이 나타날 수 있다. 검색 결과들을 하나씩 보고 파일을 접어서 사용했었는데, delete (⌫) 키를 사용하면 to-do 리스트 처럼 활용할 수 있다. 파일 혹은 해당 영역을 더 이상 보지 않는다면, delete 키를 사용하여 더 이상 나타나지 않게 할 수 있다." }, { "title": "나의 새로운 Mac 설정 목록 (Setup my personal Mac)", "url": "/posts/macbook-setup/", "categories": "", "tags": "workflow, macOS", "date": "2020-10-02 00:00:00 +0000", "snippet": " 2023.01.20 업데이트: macOS Ventura 13.1 버전 기준으로 업데이트맥os를 사용한 지 6년이 되었고, 항상 새로운 맥북 혹은 초기화 후에는 나한테 맞는 설정을 한다. 새로 설정할 때마다 가끔 까먹을 때도 있어 글을 쓰게 되었다. 혹시나 이 글을 읽게 되었다면, 해당 내용 중에 유용한 거 있으면 적용해 보아도 좋을 것 같다. 최...", "content": " 2023.01.20 업데이트: macOS Ventura 13.1 버전 기준으로 업데이트맥os를 사용한 지 6년이 되었고, 항상 새로운 맥북 혹은 초기화 후에는 나한테 맞는 설정을 한다. 새로 설정할 때마다 가끔 까먹을 때도 있어 글을 쓰게 되었다. 혹시나 이 글을 읽게 되었다면, 해당 내용 중에 유용한 거 있으면 적용해 보아도 좋을 것 같다. 최신 소프트웨어로 업데이트하기 Apple ID iCloud Drive - 데스크탑 및 문서 폴더 저장 비활성화 화면 보호기 - 드리프트로 변경 Dock 설정 크기 조절, 왼쪽, 자동으로 Dock 가리기와 보기, 최근 사용한 응용 프로그램 보기 비활성화 Dock 빈칸 생성하기 (터미널) defaults write com.apple.dock persistent-apps -array-add '{\"tile-type\"=\"spacer-tile\";}'; killall Dock Mission Control - 핫 코너 Spaces를 최근 사용 내역에 따라 자동으로 재정렬 체크 해제 Launchpad, Mission Control, 데스크탑, 디스플레이 잠자기 손쉬운 사용 - 확대/축소 확대/축소하려면 스크롤 제스처를 다음 보조 키와 함께 사용 활성화 메뉴 막대에서 Bluetooth 보기 활성화 키보드 단축키 이전 입력 소스 선택        ⌘스페이스 Spotlight 검색 보기        ⌥스페이스 텍스트 메뉴바에 나타나는 항목 빼고 모든 항목 체크박스 해제하기 트랙패드 탭하여 클릭하기 활성화 이동 속도 조절 공유 컴퓨터 이름 변경 이렇게 하면 터미널에서 컴퓨터 이름이 나타난다 Finder 보기 경로, 상태 막대 보기 환경설정 폴더 우선 정렬 활성화 사용 가능할 때 부드러운 서체 사용 Off (Big Sur 이후로는 터미널 명령어 치고 재시동) defaults -currentHost write -g AppleFontSmoothing -int 0 Spotlight 검색 카테고리 일부만 체크하기 필요한 프로그램들을 정리한 노트 기록하기 Chrome Xcode Apple Developer Git Fork VSCode Notion Twitter Fig Spotify Spark Email App 개발에 필요한 툴 설치하기 Xcode 테마 설치하기 Xcode CodeSnippets 추가하기 homebrew Mint or SwiftLint " }, { "title": "WWDC20 Dub Dub Diary, Part 5 - Data Essentials in SwiftUI", "url": "/posts/wwdc20-dubdubdiary-part5/", "categories": "WWDC", "tags": "", "date": "2020-08-18 00:00:00 +0000", "snippet": "The last day of WWDC20, ended well with many amazing sessions. This day had an interesting session, which many of developers waited. For the last article of WWDC20, let’s see the details and my las...", "content": "The last day of WWDC20, ended well with many amazing sessions. This day had an interesting session, which many of developers waited. For the last article of WWDC20, let’s see the details and my last thoughts.Data Essentials in SwifUIThis session talks about how to deal data in SwiftUI. How to design your model, and techniques for your app. They explain three key questions when starting a new view in SwiftUI, which in this session answers all that questions. What data does this view need to do its job? How will the view manipulate that data? Where will the data come from?@State, @BindingWhile creating a view, we need to know what data the view needs to render. Does the view displays the data or manipulate the data? If you are just showing the data, use let properties.struct BookCard : View { let book: Book let progress: Double var body: some View { HStack { Cover(book.coverName) VStack(alignment: .leading) { TitleText(book.title) AuthorText(book.author) } Spacer() RingProgressView(value: progress) } }}What if you are manipulating the data? Use @State and @Binding to preserve and seamlessly update the Source of Truth. @State creates a new Source of Truth, and @Binding is for sharing right access to any Source of Truth.struct EditorConfig { var isEditorPresented = false var note = \"\" var progress: Double = 0 mutating func present(initialProgress: Double) { progress = initialProgress note = \"\" isEditorPresented = true }}struct BookView: View { @State private var editorConfig = EditorConfig() func presentEditor() { editorConfig.present(…) } var body: some View { … Button(action: presentEditor) { … } ProgressEditor(editorConfig: $editorConfig) … }}struct ProgressEditor: View { @Binding var editorConfig: EditorConfig … TextEditor($editorConfig.note) …} Properties for data that isn’t mutated by the view @State for transient data owned by the view @Binding for mutating data owned by another viewObservableObject, @Published, @StateObject, @EnvironmentObject/// The current reading progress for a specific book.class CurrentlyReading: ObservableObject { let book: Book @Published var progress = ReadingProgress() @Published var isFinished = false var currentProgress: Double { isFinished ? 1.0 : progress.progress }}struct ReadingProgress { struct Entry : Identifiable { let id: UUID let progress: Double let time: Date let note: String? } var entries: [Entry]}struct BookView: View { @ObservedObject var currentlyReading: CurrentlyReading var body: some View { VStack { BookCard( currentlyReading: currentlyReading) HStack { Button(action: presentEditor) { /* … */ } .disabled(currentlyReading.isFinished) Toggle( isOn: $currentlyReading.isFinished ) { Label( \"I'm Done\", systemImage: \"checkmark.circle.fill\") } } //… } }}ObservableObject lets you connect your views to your data model. It is a data dependency surface for SwiftUI’s Views. Manage life cycle of your data Handle side-effects Integrate with existing components@Published is used on to the property of the type that conforms to ObservableObject, which SwiftUI will be notified of their changes. Automatically works with ObservableObject Publishes every time the value changes in willSet projectedValue is a PublisherThey are three types of ObservableObject, and I recommend seeing the documentation for more information. @ObservedObject creates a data dependency @StateObject ties an ObservableObject to a view’s life cycle @EnvironmentObject adds ergonomics to access ObservableObjectState and Data Flow - Apple Developer DocumentationSource of Truth LifetimeThere are two property wrapper that can automatically save and restore State. Both are lightweight Storage you use in conjunction with your model.@SceneStorage is a per-Scene scoped property wrapper. SwiftUI manage to read and write data. It is only accessible from within Views.@AppStorage is a app-scoped global storage with is persisted using user defaults. It is usable anywhere, you can access it from within your App or from your View.// SceneStoragestruct ReadingListViewer: View { @SceneStorage(\"selection\") var selection: String? var body: some View { NavigationView { ReadingList(selection: $selection) BookDetailPlaceholder() } }}// AppStoragestruct BookClubSettings: View { @AppStorage(\"updateArtwork\") private var updateArtwork = true @AppStorage(\"syncProgress\") private var syncProgress = true var body: some View { Form { Toggle(isOn: $updateArtwork) { //... } Toggle(isOn: $syncProgress) { //... } } }}Performance Tips Make View initialization cheap Make body a pure function Avoid assumptionsData Essentials in SwiftUI - WWDC 2020 - Videos - Apple DeveloperWrap UpThis WWDC20 was all new, interesting experience. Meeting so many engineers, new code-along sessions, new online labs, letting all the developers watch the session without getting the tickets. It was also my first remote conference, watching developers communicate online made the conference more connected. Although, I hope Apple runs WWDC21 in person." }, { "title": "WWDC20 Dub Dub Diary, Part 4 - Swift type inference, writing tests to fail", "url": "/posts/wwdc20-dubdubdiary-part4/", "categories": "WWDC", "tags": "", "date": "2020-08-10 00:00:00 +0000", "snippet": "For the fourth day of WWDC20, among great sessions there were two most interesting sessions about Swift language and testing. This article will talk about these two amazing sessions.Embrace Swift t...", "content": "For the fourth day of WWDC20, among great sessions there were two most interesting sessions about Swift language and testing. This article will talk about these two amazing sessions.Embrace Swift type inferenceWhat is type inference?In Swift, constant and variable needs to be specified a type at compile time. But, the compiler can figure out the type. This is able because Swift supports type inference. We can write clean, concise code with the help of Swift using type inference.// Three types of declarationlet x = \"\" // compiler can able to figure out the typelet x: String = \"\"let x = \"\" as StringThis session explains how the compiler figures out the type with our code, like solving the puzzle.Leverage type inference at the call-siteTo explain how the compiler figures out, below function was showed as an example. It was used on a SwiftUI app, to filter data.public struct FilteredList&lt;Element, FilterKey, RowContent&gt; { public init(_ data: [Element], filterBy key: KeyPath&lt;Element, FilterKey&gt;, isIncluded: @escaping (FilterKey) -&gt; Bool, @ViewBuilder rowContent: @escaping (Element) -&gt; RowContent)}FilteredList( smoothies, filterBy: \\.title, isIncluded: { title in title.hasSubstring(searchPhrase) }) { smoothie in SmoothieRowView(smoothie: smoothie)}Type inference helps us write source code faster, not spelling all the types in our code. Below is the code side by side with the initializer.Below code is how the compiler use type inference, using clues from the source code.FilteredList&lt;Smoothie, String, SmoothieRowView&gt;( smoothies as [Smoothie], filterBy: \\Smoothie.title as KeyPath&lt;Smoothie, String&gt;, isIncluded: { (title: String) -&gt; Bool in title.hasSubstring(searchPhrase) }) { (smoothie: Smoothie) -&gt; SmoothieRowView in SmoothieRowView(smoothie: smoothie)}I just showed small parts from the session, and I recommend seeing the session. It also covers how the compiler errors, and how to track and resolve it. For in-depth, learn more about Swift Generics. After watching this session, I wanted to try to create something like the example. Wish I could make it and write an article in-depth of type inference.Embrace Swift type inference - WWDC 2020 - Videos - Apple DeveloperWrite Tests to FailBesides of the session title, this session was great demonstrating a walkthrough to how to make tests for the app. Currently, I’ve been trying to write a test code for our app, so this session really help me from scratch.While getting the tests to green is important, writing the test to fail is also great for catching bugs. This is why we need to write tests to fail.Set UpUse func setUpWithError() throws to take advantage of error management. And using launchArguments or launchEnvironment to set state of the app.class RecipesTests: XCTestCase { let app = FrutaApp() override func setUpWithError() throws { continueAfterFailure = false app.launchArguments.appen(\"-recepies-tests\") app.launch()} Use func setUpWithError() throws Perform common class setup tasks Leverage launchArguments or launchEnvironment to set state Adopt product changes to focus testingTest: actionsUsing enum cases for all String value is convenient for future updates. String values can change, so capturing it with enum will be easy to update and reduce misspelling strings. Factor common code into helper functions is good for reducing repetitive codes. Design tests for a specific goal Use enums Factor common code into helper functions Model UI hierarchy in testing code Consider using a framework or Swift package to share testing codeTest: assertionsFor assertion messages, make use of optional descriptions to give more context for failure messages. And for testing asynchronous logic, use waitForExistence() then sleep().To unwrap optionals, don’t force unwrap to cause crash. Instead, follow below code.if let favs = favorites { }guard let favs = favorites else { /* throw an error */ }let favs = favorites ?? []let favs = try XCTUnwrap(favorites, \"favorites is nil, so there is nothing to count\") Add assertion messages Use relevant XCTAssert* function Unwrap optionals Use waitForExistence() for asynchronous events Throw errors from shared code Use XCTContext.runActivity() and attachments Consider XCTSkip()Tear downUse func tearDownWithError() throws to take advantage of the new error management. Use func tearDownWithError() throws Collect additional logging Reset the environmentWrite tests to fail - WWDC 2020 - Videos - Apple DeveloperWrap upWatching these two sessions gave me a refresh of Swift Language and Testing, away from SwiftUI spotlight. I recommend these sessions, it’s not very complicated subjects, and really made my mind blown." }, { "title": "WWDC20 Dub Dub Diary, Part 3 - Code-along, New Components, and build for iPad", "url": "/posts/wwdc20-dubdubdiary-part3/", "categories": "WWDC", "tags": "", "date": "2020-08-06 00:00:00 +0000", "snippet": "Many sessions were also posted on the third day of WWDC20. In particular, sessions focused on game centers were concentrated, but they were not my interests because I wasn’t developing game apps. I...", "content": "Many sessions were also posted on the third day of WWDC20. In particular, sessions focused on game centers were concentrated, but they were not my interests because I wasn’t developing game apps. I saw sessions on different topics, and there were also new types of sessions among.Widgets code-alongThere is a session where the process of developing Widgets is divided into three parts. Usually, the development process was with the presentation of the topic in one session. But this year, it was the first time that the development process was separated into a session. It was fun, and I was able to get a sense of how to develop Widgets. I didn’t immediately understand whether this code was right because I wasn’t developing the app from the beginning, but that didn’t make a big deal. It was good to learn about Widgets by developing various topics. Sometimes having these types of sessions would be good for learning new features.iOS pickers, menus and actionsThe interesting sessions were the new components from iOS 14. Using Menu, we can provide users with a more compacted and UX-friendly choice, choosing dates and times is easy through Date and time picker, and selecting wider colors through Color picker.Color PickerWith UIColorPickerViewController, you can display a color-selectable screen and select colors by three types: Grid, Spectrum and Sliders. With the new view controller, you can select or make a color easy. And it is shown in a sheet form, so it does not cover the entire screen.Date PickerWhen selecting the date and time, we used the picker view. But now we can use the dedicated picker view in iOS 14. The date of the year can be easily found and selected on the screen, and you can use keyboard to input time. You can limit only the date or time, and in iOS you can display the date and time in an inline style.MenusIn NavigationBar, easy pop backwards can be made through Menu. It is designed to replace Action sheets and popovers and can be used for various purposes such as selection and navigation. UI became simple by putting all the features that had to be shown on the screen to the menu. Below is an example from the Folders app.The new components supports multi-platform. It would be a good idea to take this opportunity to develop an app that can be developed not only on iPhones but also on iPads and even on macOS.Build for iPadWhile talking about multi-platform, I watched an iPad-related session. After watching this session, I wanted to develop a very attractive iPad app. In particular, through this session, there is a very detailed explanation of how to develop an iPad app. Using UISplitViewController, you can configure the screen to be shown on the iPad and the screen to be shown in iPhone or compact mode. You can also create a list using UICollectionView to develop a new Sidebar. Through this session, I felt it was easy to create an iPad app and thought it would be good to implement a new feature called Sidebar together.Wrap upThe more I listened to the sessions, the stronger I felt Apple’s willingness to support multi-platform. Maybe it was for the upcoming Apple Silicon and to make a general use of SwiftUI." }, { "title": "WWDC20 Dub Dub Diary, Part 2 - Widget, App clips, and SwiftUI", "url": "/posts/wwdc20-dubdubdiary-part2/", "categories": "WWDC", "tags": "", "date": "2020-07-27 00:00:00 +0000", "snippet": "On the second day of WWDC20, sessions were uploaded all at once and could be viewed immediately without waiting. Before this year, there were sessions by time and place, so waiting and listening a ...", "content": "On the second day of WWDC20, sessions were uploaded all at once and could be viewed immediately without waiting. Before this year, there were sessions by time and place, so waiting and listening a session took a long time. But this year, the sessions were released all at once, so no more waiting anymore.When listening to sessions through developer apps, it was interesting that this year there was a function to copy code script. While listening to the session, typing all the parts of code described in the session took long time, but now just copy them right away by pressing the copy button. The codes are showed along by time.Image of button copying developer app codeAlso, when looking through the list of sessions, there were surprisingly many sessions for only 10 to 20 minutes. Previously, sessions were usually prepared on a 40-minute basis, so it was very good to have such short sessions. Short sessions and smooth presentation were very good to provide only the key points of the subject.Widget, App Clips, and SwiftUIAmong the sessions, the one I wanted to hear was the new Widgets and App Clips on iOS 14. In particular, what I felt while watching these sessions was that now studying SwiftUI is much more important this year.Widgets and App Clips can be developed with SwiftUI (App Clips can also be developed with Swift and/or Objective-C). Developing these features not using UIKit, but only SwiftUI can be easy to create view or support multi-platform. But I think further more, Apple is planning to do more things with SwiftUI. In other words, SwiftUI is likely to have major part in the future.Rock Paper Scissor Game SwiftUI AppAlthough I haven’t studied SwiftUI deeply yet, I’ve developed a game app that was created simply using SwiftUI this year. At first, it was not difficult to make a screen, but it was really unfamiliar with how data was used and how the screen changed depending on the condition. I had to look for new terms and wondered if it was right to write them like this. I only had a short experience of studying it, so I thought I should study SwiftUI properly this year. If you look at the “Integration of SwiftUI” session, you can see the overall SwiftUI content and development process.Build an app entirely with SwiftUISome of the new feature of SwiftUI is that you can build an app entirely with SwiftUI. On iOS 14, with a new App protocol and new @main annotation attribute, the entry point for the app is finish. No app delegate.@mainstruct BooksApp: App { var body: some Scene { WindowGroup { ContentView() } }}As you can see, it is very familiar with the view how SwiftUI builds. For example, it looks similar with the ContentView SwiftUI code.import SwiftUIstruct ContentView: View { @State private var book = Book() var body: some View { VStack(spacing: 20) { Text(\"📚\") .font(.system(size: 24)) Text(book.name) .foregroundColor(.white) .font(.title) } }}LinkOne of the interesting part is opening a link in SwiftUI. Using Link, URL can open to a web browser or function as a app link.let websiteURL: URL = ...Section { Link(destination: websiteURL) { Label(\"Go to website\") }}There are more things that are announced in the session “What’s new in SwiftUI”. I also recommend this session also.Wrap UpWhat I noticed that Apple is really building up SwiftUI, to use and support multi-platform, build an entire app, etc. Now is the time to study SwiftUI and build a small app trying new things with it. Wish I could make an app with SwiftUI only, but also do some things that only does with UIKit. Another new stuff to study this year 😆" }, { "title": "WWDC20 Dub Dub Diary, Part 1", "url": "/posts/wwdc20-dubdubdiary-part1/", "categories": "WWDC", "tags": "", "date": "2020-07-20 00:00:00 +0000", "snippet": "From June 23 to June 26, WWDC20 was hosted online. I was lucky to win the last WWDC18 and WWDC19 event, and I went to America alone and enjoyed it. So I couldn’t feel the heat, the atmosphere and t...", "content": "From June 23 to June 26, WWDC20 was hosted online. I was lucky to win the last WWDC18 and WWDC19 event, and I went to America alone and enjoyed it. So I couldn’t feel the heat, the atmosphere and the communication with new people this year. Still, I could see what the developers were talking about on Twitter, so I felt more interactive and closer. Although a lot of time has passed, I wanted to write about WWDC20 as a blog this year, so I wrote the first one.Apple Developer ForumBefore starting, the first thing I want to talk about is the redesigned Apple Developer Forum site. It was first unveiled for WWDC20 so that it can be easily asked and answered. The questions were categorized, and there were labeled by tags. These were useful for finding questions or answers. In fact, many people asked questions through the Forum site during WWDC20, and not only Apple engineers but also other developers were able to answer them, so they were able to get answers a little faster. I thought this kind of redesigned Forum site made WWDC20 more exciting and developers got more into each other faster.KeynoteI was expecting how the keynote will show online, but it came out better than I expected. Especially, it was cool of the transition as if it was taken with a drone at Apple Park. Tim Cook, Craig Federighi and other presenters were in front of a very big TV, it was just so amazing. I felt like I was hearing alone with the presenter, and I could concentrate much more on the presentation. And it was also good that the presenter’s environment changed depending on the situation. For example, when describing the new watchOS 7 being able to recognize dance moves, it was presented by a dance studio, and when it was HomeKit, it was presented in a living room with a big TV. These details seemed to have paid a lot of attention, which made them very different from other past keynotes.iOS 14 App Library Homescreen widgets Picture in Picture App Clips Translate app Compact Siri UINew features such as App Library, Widgets, PIP and App Clips have been announced. Features that might have been seen in other OS have been added to iOS 14, but the interesting part was the App Clips. You can use apps that can be used very lightly from NFC or QR codes without installing them. If making a good use of these things, it would be great to encourage users to use the app without having to install it. If they like using it or been using it frequently, users can install it and use it as usual. I think focusing on Widgets and App Clips will be the main thing on iOS 14 this year.iPadOS 14 Compact calls UI Search (Spotlight) ScribbleIn iPadOS 14, compacted phone UI and other new features were announced. But the most memorable thing was the Scribble feature. Using an Apple pencil to write a phrase becomes text, and selecting or deleting text with the Apple pencil is now available in iPadOS 14. This feature makes iPad more useful for people studying on the iPad with the Apple pencil or writing with it. Now, little by little, Apple seem to be pushing for an inseparable relationship between the Apple pencil and the iPad.watchOS 7 Sleep tracking Hand wash detectionNew dance functions and sleep tracking functions have been added, but the hand washing feature is what I liked the most. Now that it is important to wash your hands and wear a mask, with Apple Watch you can take care of your health more than before. Just as Apple Watch cares much about health, I thought that health-related apps would be the best fit for Apple Watch in the future.macOS Big Sur New UI Design Control Center Native translations in SafariMacOS has changed the design of the UI on a large scale. I felt as if I was looking at the old iOS 7 design. The icons went back to the neumorphism design, which seems to be the middle of the design of skeuomorphism and flat. Since last year, neumorphism designs began to be seen little by little, but I never expected them to come out from macOS Big Sur new design. I felt that macOS followed the trend of design. In addition to the new UI design, control centers that were seen on iPhones and iPads have become available on macOS, and website translation functions have been added on Safari.Apple SiliconApple Silicon. ARM Mac products will be available, and iOS/iPadOS apps will be able to run natively. With Apple Silicon in the Mac, it will create a common architecture across all Apple products, developers can optimize apps for all environments. Mac products with Apple Silicon will be released at the end of the year and a complete transition will be made within two years. I want to use Mac products with Apple silicon as soon as possible.Platforms State of the UnionI once thought the Keynote was important, but what I learned after visiting WWDC19 last year is that Platforms State of the Union is a must-see session for developers. This session is for developers to learn more about new features and meet engineering leaders. In this WWDC20, we were able to meet various engineering leaders, and what was interesting was the scene where they talked about Apple Silicon through Facetime. We could briefly see more diverse features, including Sidebar function in iPadOS, color use in macOS, and a simple demonstration of Widget development in iOS 14.Wrap upThe video quality of this online WWDC was so good and was designed to focus on the presentation. I couldn’t feel the sense of realism as much as before, but was able to satisfy because I could see the developers talking about WWDC while watching it online. Although I did not enjoyed the Keynote in real time, my desire to develop more has grown whiling writing this article. From now on, I decided to write mainly on fun sessions that was released on WWDC20, and I hope good articles come out." }, { "title": "dyld: library not loaded error 해결하기", "url": "/posts/tip-dyld-library-not-loaded/", "categories": "Tips", "tags": "cocoaPods", "date": "2020-06-07 00:00:00 +0000", "snippet": "최근에 프로젝트에 TDD를 위해서 오픈소스 라이브러리 추가하여 작업 진행 중에 있습니다. RxTest 및 기타 라이브러리 추가하여 작업한 부분을 로컬 리파지토리에 병합하려고 하니 build 에러가 떴습니다. 다른 작업자분께서 작업한 부분이라 pull 받고 나서 에러가 떴는데, 아래와 같이 Xcode 콘솔에 나타났습니다.dyld: Library not ...", "content": "최근에 프로젝트에 TDD를 위해서 오픈소스 라이브러리 추가하여 작업 진행 중에 있습니다. RxTest 및 기타 라이브러리 추가하여 작업한 부분을 로컬 리파지토리에 병합하려고 하니 build 에러가 떴습니다. 다른 작업자분께서 작업한 부분이라 pull 받고 나서 에러가 떴는데, 아래와 같이 Xcode 콘솔에 나타났습니다.dyld: Library not loaded: @rpath/XCTest.framework/XCTest...Reason: image not found위 에러를 해결하려고 굉장히 많은 시간을 허비했는데(한마디로 삽질), 생각보다 간단하게 해결할 수 있었습니다. 찾다보니 RxTest 등 테스트를 위한 오픈소스 라이브러리라면 테스트 타겟일때만 추가해줘야합니다.target '{Test Target Name}' do inherit! :search_paths #Pods for testing pod 'RxTest', '5.1.1'endPodfile이 위와 같이 테스트 타겟에만 테스트 필요한 라이브러리 추가되었는지 확인하면 해당 에러는 해결됩니다." }, { "title": "git 강의 때 들었던 내용 정리", "url": "/posts/git-study/", "categories": "Study", "tags": "git", "date": "2020-05-30 00:00:00 +0000", "snippet": "대학생 때 들었던 Git 강의 내용을 종이 필기로 남겼는데, 버리기는 아까워 블로그 포스트로 옮겼습니다. 부족한 점이 있으면 알려주시면 감사하겠습니다. :D회사가 git을 안 쓰고 있다면 문제가 있다! git을 써야하는 이유? 브랜치!git config --global ~ // 지금 로그온한 계정에 전체 설정git config --list ...", "content": "대학생 때 들었던 Git 강의 내용을 종이 필기로 남겼는데, 버리기는 아까워 블로그 포스트로 옮겼습니다. 부족한 점이 있으면 알려주시면 감사하겠습니다. :D회사가 git을 안 쓰고 있다면 문제가 있다! git을 써야하는 이유? 브랜치!git config --global ~ // 지금 로그온한 계정에 전체 설정git config --list // 현재 저장소 로컬 설정/.git/ // 로컬 저장소 데이터베이스git initgit status // 작업영역 상태 확인git add ~ // 스테이지 영역 추가, 바뀐 내용, 새로운 내용git commit -m \"~\" // 커밋하면서 설명 남김 (message)git commit {id} // 고유 SHA1 값git log 기존 파일 커밋해도 변경된 내용 있으면 add 해야 함Branch 작업 상호 독립 다수 로컬 브랜치 아주 쉽게 문맥 전환 역할 구분에 활용하기 좋다 (배포/개발/테스트) 구현하려는 기능 단위 브랜치도 Good!git branch testinggit branch -v HEAD - 현재 브랜치의 최종커밋을 가리킴git checkout &lt;branch 이름&gt; // 새 브랜치로 전환 브랜치를 전환하면 작업 디렉토리 내용도 함께 바뀜// 마스터일 때git merge testing // master에도 변경 내역을 반영 -&gt; 합치기(merge)// 되돌리기git reset --hard {커밋ID(7자리)} master와 브랜치가 각자 길을 가고 있다면 공통 조상 찾아서 처리// 로그 간단히 보기git log --oneline// remote 저장소로 pushgit remote add &lt;name&gt; &lt;url&gt;git revert &lt;커밋ID&gt; // 복구, 역커밋 Fast-forwardrevert 역커밋생성된 것 -&gt; 없앤다수정한걸 -&gt; 원래대로 복구프로젝트 포크(Fork) 특정 저장소를 내 영역(단체/개인)으로 복제 별도 작업 진행 후, Pull Request 전송 수락되면 merge 됨 copy of a repository propose changes to someone else’s progject -&gt; bug fix instead of using a single server-side repository,every developer has their own server-side repository clone이랑 다르게 personal public repositoryGit 강의T아카데미 강연자료" }, { "title": "Add image to string in UILabel using NSTextAttachment", "url": "/posts/add-image-to-string-in-uilabel/", "categories": "Tips", "tags": "iOS", "date": "2020-05-04 00:00:00 +0000", "snippet": "Sometimes you need to add image to a string in a UILabel, but using UIImageView gets complicated and sometimes not efficient. But Apple provides a simpler way, using NSAttributedString and NSTextAt...", "content": "Sometimes you need to add image to a string in a UILabel, but using UIImageView gets complicated and sometimes not efficient. But Apple provides a simpler way, using NSAttributedString and NSTextAttachment. Here’s how you do it.let stringWithImage = NSMutableAttributedString(string: \"Completed\")let imageAttachment = NSTextAttachment()imageAttachment.image = UIImage(named: \"completeIcon\")let completeImageString = NSAttributedString(attachment: imageAttachment)stringWithImage.append(NSAttributedString(string: \" \"))stringWithImage.append(completeImageString)labelComplete.attributedText = stringWithImageThis way is more easier than using UIImageView. We don’t need any Auto Layout, just a plain NSMutableAttributedString." }, { "title": "개인적으로 추천하는 도움이 되는 iOS 공부 자료", "url": "/posts/ios-study/", "categories": "Tips", "tags": "iOS", "date": "2020-04-03 00:00:00 +0000", "snippet": "해당 포스트는 개인적으로 iOS 공부할 때 도움이 되는 책, 인터넷 자료, 강의 등을 모아놓은 글입니다. 개인에 따라 도움이 되는 자료일 수 있고, 아닐 수 있기 때문에 가볍게 참고용으로 보시면 좋을 것 같습니다. :) 책, 인터넷 자료, 강의1. 책 Intro to App Development with Swift 영어로 되어 있지만, Ap...", "content": "해당 포스트는 개인적으로 iOS 공부할 때 도움이 되는 책, 인터넷 자료, 강의 등을 모아놓은 글입니다. 개인에 따라 도움이 되는 자료일 수 있고, 아닐 수 있기 때문에 가볍게 참고용으로 보시면 좋을 것 같습니다. :) 책, 인터넷 자료, 강의1. 책 Intro to App Development with Swift 영어로 되어 있지만, Apple에서 만든 책으로 Swift Playground을 이용해서 문법과 기본적인 동작을 배우고, 앱을 개발할 수 있는 내용도 있음. 한 챕터 끝날 때마다 퀴즈를 풀어 복습할 수 있음. Intro to App Development with Swift raywenderlich 책 시리즈 영어로 되어 있지만, 꽤 많은 iOS 및 안드로이드 개발자들이 책을 사서 공부함 분야별로 나뉘어져 있어, 필요한 것만 구입하여 볼 수 있음 raywenderlich.com Store 2. 인터넷 자료 100 Days of Swift (무료) 100일 동안 매일 스위프트 공부할 수 있는 커리큐럼 스위프트 문법부터 시작해서 예제 프로젝트까지 다양하게 할 수 있음 100일 동안 꾸준히 공부할 수 있게 양이 조절 되어 있음 단, 영어로 되어 있음 100 Days of Swift - Hacking with Swift 유튜브 채널 추천 Lets Build That App 유튜브, 페이스북, 인스타그램 등 다양한 앱들을 만들어보는 프로젝트 시리즈로 만들어 유튜브 채널에 올림 짤막하게 기능 구현하는 동영상도 있어 필요한 부분만 찾아 봐도 무방 유료로 된 강의를 올리는 사이트 있어, 필요한 기능들이 있는 앱 강의 구입하여 수강해도 좋음 단, 영어로 되어 있음 Lets Build That App 3. 강의 GitHub Followers (유료, $149) 개인 예제 프로젝트로, 회사 입사하기 전 과제 형태로 준비되어 있어 입사할 때 도움이 될 것 최신 기술부터 시작해서 네트워킹, 검색 UI, CollectionView 등 다양하게 화면을 작업 및 기능 구현할 수 있음 제일 추천하는 강의 단, 영어로 되어 있음 Sean Allen LBTA 강의 (유료, 프로젝트별로 가격이 다름) 현재 진행하는 프로젝트의 특성에 맞게 구매하여 수강해도 좋음 다양한 기능들을 공부할 수 있고, 최근에는 NodeJS 등 풀 스택 강의도 있음 단, 영어로 되어 있음 Courses 기타커뮤니티 Swift Korea 페이스북 Swift Korea 컨퍼런스 WWDC WWDC21 웹사이트 Hacking with Swift Hacking with Swift - learn to code iPhone and iPad apps with free Swift 5.1 tutorials Raywenderlich raywenderlich.com NSHipster NSHipster " }, { "title": "How to detect current text while texting in UITextField", "url": "/posts/detect-current-text-in-textfield/", "categories": "Tips", "tags": "iOS", "date": "2020-03-31 00:00:00 +0000", "snippet": "While typing a text in UITextField, we could get the current text with UITextFieldDelegate’s Instance Method textFieldDidChangeSelection(_:). But this method only works at iOS 13.0+, so to let othe...", "content": "While typing a text in UITextField, we could get the current text with UITextFieldDelegate’s Instance Method textFieldDidChangeSelection(_:). But this method only works at iOS 13.0+, so to let other lower iOS version to use this is how it works.Add a target to UITextFieldtextField.addTarget(self, action: #selector(handleTextFieldDidChange), for: .editingChanged)Handle event when UITextField editing changed@objc func handleTextFieldDidChange(_ textField: UITextField) { // handle event print(textField.text) // this prints the text of textField after typing}On iOS 13.0+But when your app only supports iOS 13.0+, you can use the method below.func textFieldDidChangeSelection(_ textField: UITextField) { // handle event}Apple Document stackoverflow" }, { "title": "Ad Hoc 방식으로 iOS 앱 개발하는 방법", "url": "/posts/ios-adhoc/", "categories": "", "tags": "iOS, deploy", "date": "2020-03-29 00:00:00 +0000", "snippet": "예전에 사내용으로 앱을 개발하여 배포했던 적이 있었다. 사내용으로 만들 때는 Enterprise 개발자 계정으로 Ad Hoc 또는 Enterprise 용으로 앱을 만들어 배포할 수 있는데, 그중에 Ad Hoc 방식으로 했던 것들을 정리해보았다. (개인적으로 보려고 작성해서 이해하기 힘들 수 있다.)iOS 앱 만들기 Bundle Identifier :...", "content": "예전에 사내용으로 앱을 개발하여 배포했던 적이 있었다. 사내용으로 만들 때는 Enterprise 개발자 계정으로 Ad Hoc 또는 Enterprise 용으로 앱을 만들어 배포할 수 있는데, 그중에 Ad Hoc 방식으로 했던 것들을 정리해보았다. (개인적으로 보려고 작성해서 이해하기 힘들 수 있다.)iOS 앱 만들기 Bundle Identifier : 앱의 유일한 식별자, 코드 인증과 개발자 인증에 매우 중요한 정보Provisioning Profile 만들기 App ID, Certificates, Devices 코드 인증, 디바이스 인증 담당. 앱 개발에 중요한 프로파일 개발자 사이트 로그인 -&gt; iOS provisioning profile 만듦Ad Hoc provisioning profile-&gt; distribution -&gt; Ad Hoc -&gt; 인증될 앱 App ID -&gt; 개발자의 certificates -&gt; 등록된 디바이스 선택 -&gt; provisioning profile의 이름 입력 -&gt; generate -&gt; distribution provisioning profileXcode 설정 Code sign과 provisioning profile 설정 배포할 때 개발용 프로비저닝 선택 XIPA 생성 (시뮬레이터 말고 General device로 설정) Product -&gt; Archive -&gt; Export -&gt; Save for Ad Hoc Deployment -&gt; 개발자 계정 로그인 -&gt; ipa 파일 이름 지정.저장Dropbox를 통한 https 서버 사용 및 pllist 파일, 앱 다운로드 웹페이지 생성 드롭박스 업로드 후 링크 공유 -&gt; dl.dropboxusercontent.com 주소 변환 -&gt; pllist 파일 생성 -&gt; 드롭박스 업로드 후 링크 공유 -&gt; dl.dropboxusercontent.com 주소 변환 -&gt; 이 주소를 웹페이지에 a 태그 url 주소로 넣기 -&gt; 웹페이지로 앱 설치 확인하기plist 템플릿&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;items&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;assets&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software-package&lt;/string&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;[INSERT URL HERE]&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;metadata&lt;/key&gt; &lt;dict&gt; &lt;key&gt;bundle-identifier&lt;/key&gt; &lt;string&gt;[INSERT BUNDLE ID HERE]&lt;/string&gt; &lt;key&gt;bundle-version&lt;/key&gt; &lt;string&gt;[INSERT VERSION HERE]&lt;/string&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software&lt;/string&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt;[INSERT APP TITLE HERE]&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt;&lt;/dict&gt;&lt;/plist&gt;" }, { "title": "CocoaPods 팁 (설치부터 오류 해결)", "url": "/posts/tips-cocoapods/", "categories": "Tips", "tags": "cocoaPods", "date": "2020-03-21 00:00:00 +0000", "snippet": "앱 프로젝트 진행하다 보면, 오픈소스 라이브러리를 사용할 때가 있다. Xcode 프로젝트에 오픈소스 라이브러리를 설치 및 연결하는 방법이 CocoaPods, Carthage 또는 Swift Package Manager를 사용한다. 대표적으로 CocoaPods를 많이 사용하는데, CocoaPods 이용할 때 유용한 팁들을 정리해 보았다.CocoaPods...", "content": "앱 프로젝트 진행하다 보면, 오픈소스 라이브러리를 사용할 때가 있다. Xcode 프로젝트에 오픈소스 라이브러리를 설치 및 연결하는 방법이 CocoaPods, Carthage 또는 Swift Package Manager를 사용한다. 대표적으로 CocoaPods를 많이 사용하는데, CocoaPods 이용할 때 유용한 팁들을 정리해 보았다.CocoaPods 란? CocoaPods is a dependency manager for Swift and Objective-C Cocoa projects.스위프트와 오브젝티브-C 코코아 프로젝트를 위한 의존성 매니저. 쉽게 말해 오픈소스 라이브러리를 프로젝트와 연결시키면서 개발자들이 편리하게 사용할 수 있게 해주는 환경 또는 도구.좋은 점- 업데이트 명령어를 실행하면 프로젝트 버전에 맞춰서 설정한 오픈소스 라이브러리를 업데이트해 버전 관리하기가 편하다- 되도록이면 CocoaPods에 등록되어 있는 라이브러리들을 설치 권장CocoaPods 설치$ sudo gem install cocoapodsCocoaPods 설정하기 프로젝트 생성 워크스페이스(workspace) 생성 워크스페이스에서 오른쪽 버튼을 눌러 Add Files to “”… 메뉴를 클릭해서 작업할 프로젝트를 워크스페이스 안에 추가함 root 프로젝트 폴더에서 podfile를 생성하여 연결할 오픈소스 라이브러리를 추가함 terminal에서 pod install를 입력하여 연결시킴 $ pod install or 프로젝트를 생성한 다음, 프로젝트 폴더에서 pod init 명령어를 실행 -&gt; 알아서 Podfile이 생성되고 워크스페이스가 생김 $ pod init Podfile을 설정한 다음 pod install 명령어를 쳐서 실제 프로젝트와 연결함 $ pod install Podfile 예시platform :ios, '13.0'use_frameworks!target 'MyApp' do pod 'Alamofire', '~&gt; 5.0' pod 'SwiftyJSON', '~&gt; 4.0'end설치하면서 로그 보고 싶다면 아래 명령어처럼 뒤에 --verbose 붙이면 된다.$ pod install --verbose // Show more debugging informationCocoaPods 관련 오류1. 특정 파일이 안 보인다.\"/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sqlite3.h\" not found\"-&gt; cocoapods 재설치$ sudo gem install cocoapods$ pod install --verbose참고 -&gt; Xcode.app 과 Xcode-beta.app은 다르므로, Xcode 프로그램 이름과 프로그램이 위치해 있는 디렉토리 잘 확인하자! (Xcode 프로그램 응용 프로그램 폴더에 넣기)2. 특정 module 빌드 에러\"Could not build module firebase core\" Error-&gt; Xcode 종료 -&gt; project’s temp file 삭제 (~/Library/Developer/Xcode/DerivedData — Xcode-&gt;Preference-&gt;Location에 위치해 있음) -&gt; ProjectName.xcworkspace 삭제 -&gt; Podfile.lock 파일이랑 Pods 폴더 삭제 -&gt; pod install 실행 (터미널) -&gt; 새로 생성한 ProjectName.xcworkspace 실행하여 다시 빌드하기-&gt; 그래도 안된다면? —&gt; pod update (or) —&gt; pod –version 체크 (or) —&gt; pod repo update —&gt; Podfile에 ‘Firebase’ 주석 처리 —&gt; pod install (old Firebase가 제거된다) —&gt; Podfile에 ‘Firebase’ 주석 해제 —&gt; pod install (new Firebase 설치) ——–&gt; 해결 완료!Referencestackoverflow groups-firebase3. CocoaPods 설치 후 콘솔 로그 에러\"The &lt;project name [Debug/Release]&gt; target overrides the 'ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES' build setting defined in 'Pods/Target Support Files/Pods-/Pods-.debug(or release).xconfig'. This can lead to problems with the CocoaPods installation.\"&lt;/code&gt;-&gt; Targets -&gt; Build Settings -&gt; Build Options -&gt; Always Embed Swift Standard Libraries -&gt; Other… -&gt; $(inherited) -&gt; pod installReferenceCocoaPods Issue stackoverflow4. 특정 라이브러리만 업데이트하기pod update {Pod Name}" }, { "title": "Info.plist Localization", "url": "/posts/info-plist-localization/", "categories": "", "tags": "iOS, localize", "date": "2020-01-24 00:00:00 +0000", "snippet": "Recently, one of our app got rejected by App Store Connect, because it needed to update NSPhotoLibraryUsageDescription content. There was not enough reason why our app need to access user’s photo l...", "content": "Recently, one of our app got rejected by App Store Connect, because it needed to update NSPhotoLibraryUsageDescription content. There was not enough reason why our app need to access user’s photo library. While solving the issue, I wanted to add localized message for it. This post will show how to localize of Info.plist.Add new Strings FileFirst, add a new Strings File naming “InfoPlist”.Enable LocalizationWhile InfoPlist.strings file selected, press Localize… button in the file inspector panel.After pressing the button, you will get localized files like below.Add Localized MessageAdd localized description for each file that matches the language. You can change the app name to match the language of the country (CFBundleDisplayName and CFBundleName). The keys must be added to Info.plist file, or the localization will not work well.// For App's NameCFBundleDisplayName = \"내튜브\";CFBundleName = \"내튜브\"; // For Photo Library AccessNSPhotoLibraryUsageDescription = \"{Photo Library Access Message}\";TestTesting on the simulator, you need to change the language from the simulator’s setting app. Testing on a real device is also the same way as simulator.ConclusionWhile solving the issue of 5.1.1 Data Collection and Storage, I didn’t know it has to give a very specific reason of access it. Make sure your app gives a very good description on why the app needs to access it.ReferenceAbout Information Property List Files" }, { "title": "Add Refresh Control to Collection View", "url": "/posts/add-refesh-control-to-collection-view/", "categories": "", "tags": "iOS", "date": "2020-01-19 00:00:00 +0000", "snippet": "I’ve been currently rebuilding a project that I’m working on, and there were some UI issues when refreshing datas. UIRefreshControl was implied for pull-to-refresh style, but the project deployment...", "content": "I’ve been currently rebuilding a project that I’m working on, and there were some UI issues when refreshing datas. UIRefreshControl was implied for pull-to-refresh style, but the project deployment target was iOS 8 and some old codes were left. After changing the code, I wanted to write a post about it. So this post will show how to add pull-to-refresh style to collection view or other scroll views.UIRefreshControl starting in iOS 10In pre-iOS 10, UIRefreshControl was added as a subview like below.let refreshControl = UIRefreshControl()refreshControl.addTarget(self, action: #selector(reloadCurrentView), for: UIControlEvents.valueChanged)collectionView.addSubview(refreshControl)Starting in iOS 10, you can add a UIRefreshControl as a property to UIScrollView.let refreshControl = UIRefreshControl()refreshControl.addTarget(self, action: #selector(handleRefresh), for: .valueChanged)collectionView.refreshControl = refreshControl @objc func handleRefresh() { // Update your content… // Dismiss the refresh control. DispatchQueue.main.async { self.collectionView.refreshControl?.endRefreshing() }}UIRefreshControl AttributesYou can change the tint color and add title text while displaying the refresh control.let refreshControl = UIRefreshControl()let title = \"Pull to refresh\"refreshControl.tintColor = .yellowrefreshControl.attributedTitle = NSAttributedString(string: title, attributes: [.foregroundColor : UIColor.yellow])refreshControl.addTarget(self, action: #selector(handleRefresh), for: .valueChanged)tableView.refreshControl = refreshControlIf you can handle when the data is fetched or while fetching, you can change attributedTitle like below.Wrap upAdd UIRefreshControl if you need a pull-to-refresh control for your list page or more. Using it and customizing is easy.ReferenceUIRefreshControl - UIKit" }, { "title": "How to deal with scroll view content size with storyboard", "url": "/posts/scrollview-contentsize-storyboard/", "categories": "", "tags": "iOS, ui development, storyboard", "date": "2020-01-10 00:00:00 +0000", "snippet": "UIScrollView is very useful when presenting content that are larger than a single screen. I’ve been using it to support iPhone SE users or iPhone 8 users to let them scroll and see contents.I prefe...", "content": "UIScrollView is very useful when presenting content that are larger than a single screen. I’ve been using it to support iPhone SE users or iPhone 8 users to let them scroll and see contents.I prefer using Interface Builder to add or modify UIScrollView that is already used in a UIViewController. At first, it was fustrating how to set the content size and other errors when using UIScrollView (especially scrollable content size ambiguity error). This post is going to describe how to use UIScrollView in Storyboard that helped me alot.StepsThis is an example of one UIViewController that has a UIScrollView. When it was first made, it was matched with iPhone 5. But after setting the storyboard view as iPhone 11, the layouts are not setted well. It’s because the UIScrollView layouts were not properly setted before. Let’s fix this problem.Step 1The UIView inside UIScrollView need below constraints. Leading, trailing, top and bottom constraints (all zero).Step 2Add a UIView that contains the UIScrollView. This view needs below constraints. Leading, trailing, top and bottom constraints (all zero to Superview).Step 3Add equal height, equal width contraints to the UIView inside UIScrollView to the UIView that contains UIScrollView. Add equal height, equal height (to the UIView that contains UIScrollView). Set priority to low for equal height. Check the UIScrollView’s constraints. UIScrollView constraints needs to be setted as below. 2-1. Leading, trailing, top and bottom constraints (all zero to Superview).After the steps, you can run different devices and see it will scroll through all content. And also in the storyboard you will no longer see any red error like ‘Scrollable Content Size Ambiguity Error’. 👏If you still can’t scroll, try adding scrollView.contentSize in viewWillLayoutSubviews function.override func viewWillLayoutSubviews() { super.viewWillLayoutSubviews() scrollView.contentSize = CGSize(width: self.view.frame.size.width, height: 600)}ConclusionEven though large phones are common, there are still users that use small phones. It’s best to support all devices using auto layout.Thanks for reading!ReferenceCalculating contentSize for UIScrollView when using Auto Layout" }, { "title": "Use Sets for unique", "url": "/posts/ios-tip-1-sets/", "categories": "", "tags": "swift", "date": "2019-11-30 23:30:00 +0000", "snippet": "If there is something you need to handle data unique, use Sets instead of Array.Sets are like array, but there are some difference. It is not stored in order. Use array instead. No duplicate item...", "content": "If there is something you need to handle data unique, use Sets instead of Array.Sets are like array, but there are some difference. It is not stored in order. Use array instead. No duplicate items can be stored. All items are unique.let arrayOfFruit = [\"Apple\", \"Banana\", \"Carrot\", \"Durian\"]// [\"Apple\", \"Banana\", \"Carrot\", \"Durian\"]let setOfFruit = Set([\"Apple\", \"Banana\", \"Carrot\", \"Durian\"])// {\"Durian\", \"Banana\", \"Apple\", \"Carrot\"}If you write the code above in the playground, you can see that the value of set in unordered.let setOfFruitDuplicate = Set([\"Apple\", \"Banana\", \"Carrot\", \"Durian\", \"Apple\"])// {\"Apple\", \"Carrot\", \"Durian\", \"Banana\"}Also, if you duplicate the value like above, you only get unique values. Above set would only include Apple, Banana, Carrot, Durian.Because of having unique data, set is good for finding if there is any duplicated data. For example, counting the data would be good for finding if the data has duplicated data.If there is a duplicated data, set would not include that, so it would have less count beside of the original data.let arrayOfFruitDuplicate = [\"Apple\", \"Banana\", \"Carrot\", \"Durian\", \"Apple\"]let setOfFruitDuplicate = Set([\"Apple\", \"Banana\", \"Carrot\", \"Durian\", \"Apple\"])arrayOfFruitDuplicate.count == setOfFruitDuplicate.count// it will return false" }, { "title": "깃허브(GitHub) 블로그 jekyll 테마 커스텀(custom)하기", "url": "/posts/custom-jekyll-theme/", "categories": "", "tags": "blog", "date": "2019-11-17 22:30:00 +0000", "snippet": "어제 깃허브 블로그 구축하고 나서 꾸미려고 하니깐 뭔가 마음대로 꾸밀 수 없는 걸 느껴서, 테마를 가져와서 내 입맛대로 꾸밀 수 있을까 찾다가 jekyll theme을 fork 해서 커스텀할 수 있는 방법이 있다고 했다. 오늘 포스트는 테마를 조금 커스텀 할 수 있는 부분에 대한 내용을 담았다.소스에 있는 세팅들 보다가 수정하고 싶은 부분이 생겼는데,...", "content": "어제 깃허브 블로그 구축하고 나서 꾸미려고 하니깐 뭔가 마음대로 꾸밀 수 없는 걸 느껴서, 테마를 가져와서 내 입맛대로 꾸밀 수 있을까 찾다가 jekyll theme을 fork 해서 커스텀할 수 있는 방법이 있다고 했다. 오늘 포스트는 테마를 조금 커스텀 할 수 있는 부분에 대한 내용을 담았다.소스에 있는 세팅들 보다가 수정하고 싶은 부분이 생겼는데, css 를 건드릴 수 있는 부분이 없었다. Padding을 줄이거나, icon을 추가하거나 등 세팅할 수 있는 부분을 찾을 수가 없었다.(css 관련된 부분들을 찾을 수가 없다)깃헙 블로그 테마를 적용하는 방법이 두 가지가 있었는데, 어제 구축한 방법은 테마를 기본적으로 그냥 가져와서 세팅하는 방법이다. 굳이 커스텀 할 필요를 못 느낄 정도로 테마가 잘 되어 있으면 이 방법을 쓰면 된다. 하지만 뭔가 조금 더 꾸미고 싶은 부분이 있다면, 해당 테마를 fork 해서 가져와서 조금 수정해서 쓰는 방법이 있다. Fork는 리포지토리를 다 복사해서 새로운 리포지토리로 붙여놓는다고 보면 된다 (Copy and Paste).현재 적용하고 있는 Texture GitHub 프로젝트 가서 상단에 있는 Fork 누르면 본인 계정에 새로운 리포지토리가 생성하면서 fork가 된다.Fork가 다 되면 새로운 리포지토리가 생성이 되어 있고, 해당 리포지토리의 Setting으로 가서 리포지토리 이름을 다시 {username}.github.io 로 변경한다.Fork 한 프로젝트 안의 파일들을 보면 테마마다 다르겠지만 assets, layouts, includes 등 처음에 그냥 테마 설치하여 적용했을 때보다 많은 폴더가 있다. 여기서부터는 각자 적용한 테마들의 커스텀 하는 방법 참고하여 진행하면 된다. README 파일에 설명되어 있을 수 있고, 아니면 직접 소스 분석하면서 수정하면 된다. 아래부터는 Texture jekyll theme 한해서 이 깃헙 블로그에 적용한 것들을 일부 소개하고 있다.Texture jekyll theme custom - 1. instagram icon 추가적용한 테마 디자인 중 twitter, github 등 소셜 링크 추가한 것들이 있는데, 개인적으로 인스타그램도 넣으면 어떨까 하고 소스 분석해봤다. page_header.html 파일에 관련한 소스들이 있어 instagram 계정 추가하고 개발 서버로 한번 돌렸는데 인스타그램 아이콘이 나타나지 않았다.{%- if site.texture.social_links.instagram -%}\t&lt;a href=\"https://instagram.com/{{ site.texture.social_links.instagram }}\"&gt;&lt;li&gt;&lt;i class=\"icon-instagram\"&gt;&lt;/i&gt;&lt;/li&gt;&lt;/a&gt;{%- endif -%}관련해서 더 찾다 보니 scss 파일을 통해서 아이콘을 적용하는 것 같은데, 아이콘 파일들은 assets에 없었다. 유심히 소스 보니깐 fontello 폰트를 사용하는 거로 봐서, fontello 폰트 안에 있는 아이콘을 쓰는 게 아닐까 생각이 들었다. Fontello 사이트 들어가서 확인해보니깐 아이콘들이 있었으며, 기존에 사용하고 있는 트위터와 깃허브 아이콘들이 있었다.(Fontello website)원하는 instagram 아이콘 선택해서 다운로드하고 font 폴더에 있는 것들을 덮어쓰기 하니깐 이제는 기존에 나오는 아이콘들이 나타나지 않았다. 다운받은 폰트 관련 파일 안에는 이전에 적용되어 있던 아이콘에 대한 설정들이 없었고 인스타그램 아이콘만 관련된 설정들이 있어서 나타나지 않았던 것이었다. 다시 관련된 아이콘들을 찾아서 포함하여 다운받고 다시 적용하니깐 잘 나왔다.(instagram 아이콘은 나타났지만, 이전에 나타났던 아이콘들은 나오지 않았다)(새로 다운받은 폰트 관련 파일 중 하나. 관련된 아이콘들에 대한 설정들이 있다)(새로 다운받은 폰트 관련 파일들을 적용하고 나서 이전에 나타난 아이콘과 새로운 인스타그램 아이콘이 나온다)Jekyll 테마마다 다 다르겠지만, 지금의 테마에서는 fontello 폰트 이용하여 아이콘들을 사용하고 있기 때문에 새로운 아이콘 적용하고 싶으면 fontello 사이트에 들어가서 기존 + 새로운 아이콘 포함하여 새로 다운 받아야 한다. 다운받은 뒤, 관련 파일들을 다 적용하고 css 관련해서 추가하면 된다.Texture jekyll theme custom - 2. 모바일 환경에서 날짜가 제목 밑으로 나타나기깃허브 블로그 만들고 나서 기쁜 마음으로 침대에 누우면서 잠들기 전에 스마트폰으로 들어갔는데, 날짜 관련 부분이 제목 옆으로 나와서 뭔가 이뻐 보이지 않는 느낌이 들었다.(밑으로 내려가 줘….)이 부분 때문에 jekyll 테마를 커스텀 하고 싶었던 첫 번째 이유이기도 했다. 오랜만에 css 관련 속성들을 찾으면서 적용하고 수정하고 다시 적용하면서 관련 디자인 부분을 추가했다. 모바일 환경에서만 적용이 필요하기 때문에 관련된 부분도 찾으면서 적용했다. 아래는 css 관련 추가한 코드다.@media screen and (max-width: $mobileWidth) { display: block;}(왼쪽은 적용 전, 오른쪽은 적용 후. 태그 관련된 부분은 아래에 다룰 예정이다)Texture jekyll theme custom - 3. 포스트 관련 태그 나타나기포스트 안에 태그들이 있는데, 이 태그들이 포스트 목록에도 나오면 좋을 것 같은 생각이 들어서 관련 내용 추가하기로 했다.일단 태그 관련된 부분을 나타내기 위해 div 태그 새로 추가해서 tag 가 나오게 했다.&lt;div class=\"post-tag\"&gt; &lt;ul class=\"post-tag-container\"&gt; {%- for tag in post.tags -%} &lt;li&gt;tag&lt;/li&gt;\t{%- endfor -%} &lt;/ul&gt;&lt;/div&gt;그리고 나서 태그와 포스트 짧은 본문 내용 부분과 떨어지도록 아래 css style 추가했다..post-tag {\tmargin-top: 5px;\tdisplay: inline-block;\tmargin-bottom: -10px;}마지막으로 포스트 목록에 나타나는 태그들 관련 css style 추가하여 완성했다.(왼쪽은 적용 전, 오른쪽은 적용 후. 이제 태그들만 보고 어떤 내용인지 예상할 수 있고, 보고 싶은 내용만 볼 수 있어서 좋을 듯하다)마무리마음에 드는 테마들이 있지만, 조금 더 커스텀 할 수 있도록 fork 하는 방법과 예시로 texture 테마에서 수정한 몇 가지들을 소개해 봤다. 더 적용해야 하는 부분들이 있지만, 일단 지금까지만 수정하고 차근차근하도록 해야겠다. 그리고 오랜만에 css 공부하니깐 굉장히 어색했다." }, { "title": "깃허브(GitHub) 블로그 구축하기", "url": "/posts/set-github-page/", "categories": "", "tags": "blog", "date": "2019-11-15 00:00:00 +0000", "snippet": "개발자들이라면 한 번이라도 봤을 만한 블로그 주소는 {username}.github.io 일 것이다. 개인적으로 깃허브 블로그 페이지 만들면서 고생해서 간단하고 최소한의 작업으로 구축하는 방법을 기록하기 위해 포스트를 쓰기로 했다.먼저 GitHub 계정으로 새로운 리파지토리(repository)를 만들면 된다. 자세한 설명은 GitHub Pages 사...", "content": "개발자들이라면 한 번이라도 봤을 만한 블로그 주소는 {username}.github.io 일 것이다. 개인적으로 깃허브 블로그 페이지 만들면서 고생해서 간단하고 최소한의 작업으로 구축하는 방법을 기록하기 위해 포스트를 쓰기로 했다.먼저 GitHub 계정으로 새로운 리파지토리(repository)를 만들면 된다. 자세한 설명은 GitHub Pages 사이트 가면 된다.영어로 되어 있지만, 간단하기 때문에 문제없을 것 같다.Hello World 까지 찍히는 거 보면 이제부터는 테마를 이용해서 꾸미는 작업이 필요하다. 보통 지킬(jekyll) 이용해서 테마를 입히는데, 테마를 입히기 위해서는 필요한 명령어들이 있다. 먼저 그 명령어들을 사용할 수 있게 기본 세팅을 설정했다. 사용하는 터미널(Terminal) 프로그램 열고 아래와 같은 명령어들을 실행하면 된다. Jekyll 페이지 들어가보면 더 자세한 설치 방법과 적용 방법들이 있다.$ gem install bundler jekyll$ jekyll new my-awesome-site$ cd my-awesome-site~/my-awesome-site $ bundle exec jekyll serve만약 bundler가 없으면 아래 명령어로 설치하면 된다.$ gem install bundler웹 페이지에 필요한 jekyll 파일들 설치하고 브라우저로 http://localhost:4000 에 접속하면 확인할 수 있다.Jekyll Themes 페이지 혹은 Github에 jekyll 테마 검색해서 마음에 드는 테마를 고르면 된다. 여기서 Texture 테마를 입히기로 했다.깔끔 깔끔테마마다 적용하는 방법이 다르다. Github 페이지의 README 참고하여 적용하면 된다. 테마마다 사용할 수 있는 설정들이 있어 적용하면서 마음에 들지 않으면 다른 테마 찾아서 적용해도 좋을 것 같다.천천히 조금씩 설정하여 아래와 같이 초기 화면을 만들었다.Jekyll 테마 입히고 http://localhost:4000 에 접속하여 미리 어떤 모습으로 보일지 확인할 수 있다. 먼저 bundle 설치하고 bundle exec jekyll serve 명령어 실행하면 된다.$ bundle install$ bundle exec jekyll serve페이지 추가하고 편집하면서 저장하면, 실행 중에 변경된 내용을 확인할 수 있다. 하지만 _config.yml 파일을 변경했으면 테스트로 실행 중인 것을 멈추고 다시 서버를 가동하여 확인해야 한다.정말 최소한의 구축 설정으로 한 것이다. 갓허브로 리파지토리 만들고, jekyll 설정하여 기본 세팅을 한 뒤, 마음에 드는 jekyll 테마를 찾아서 입히는 작업까지만 했다. 앞으로 포스팅하면서 더 이쁘게 꾸미는 방법을 찾으면서 깃허브 블로그 관리하도록 노력해야겠다. 이 짧은 글이 처음으로 깃허브 블로그 구축하는 분들께 도움이 되길 바라며, 다음 포스트에서 볼 수 있으면 좋겠다." } ]
